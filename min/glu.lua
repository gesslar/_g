if not _G["Glu"] then Glu={} Glu.__index=Glu table.unpack=table.unpack or unpack local registeredGlasses={} function Glu.getGlasses()return registeredGlasses end function Glu.getGlassNames()local names={} local glasses=Glu.getGlasses()for _, glass in ipairs(glasses or {})do table.insert(names, glass.name)end return names end function Glu.getGlass(name)for _, glass in ipairs(Glu.getGlasses())do if glass.name==name then return glass end end return nil end function Glu.hasGlass(name)return Glu.getGlass(name)~=nil end function Glu.id()local function random_hex(length)return string.format("%0" .. length .. "x", math.random(0, 16 ^ length-1))end local result=string.format("%s%s-%s-4%s-%x%s-%s%s%s", random_hex(4), random_hex(4), random_hex(4), random_hex(3), 8+math.random(0, 3), random_hex(3), random_hex(4), random_hex(4), random_hex(4))return result end setmetatable(Glu, { __call=function(_, ...)return Glu.new(...)end })local function newObject(instance, glass, instance_opts, container)local function checkIndexForLoop(g)local seen={} local current=g while current do if seen[current] then print("Loop detected in __index chain for:", g.name)return true end seen[current]=true current=getmetatable(current)and getmetatable(current).__index end return false end local function copyProperties(c, i)local object=i[c.name] for k, v in pairs(object)do instance[c.name][k]=v end local meta=getmetatable(object)if meta then setmetatable(instance[c.name], meta)end end local function instantiate(i, g, i_opts, cont)if checkIndexForLoop(g)then return end if g.inherit_from then local parentName=g.inherit_from.name if not i[parentName] or #table.keys(i[parentName])==0 then instantiate(g.inherit_from, i, i_opts, cont)end end if not i[g.name] or #table.keys(i[g.name])==0 then local object=g(i_opts, i)i[g.name]=object copyProperties(g, i)end end instantiate(instance, glass, instance_opts, container)end function Glu.new(pkg, module_dir_name)assert(type(pkg)=="string", "Package name must be a string.")assert(type(module_dir_name)=="string" or module_dir_name==nil, "Module directory name must be a string or nil.")local instance={ name="Glu", package_name=pkg, module_dir_name=module_dir_name, objects={}, container=nil, TYPE={ BOOLEAN="boolean", ["boolean"]="boolean", FUNCTION="function", ["function"]="function", NIL="nil", ["nil"]="nil", NUMBER="number", ["number"]="number", STRING="string", ["string"]="string", TABLE="table", ["table"]="table", THREAD="thread", ["thread"]="thread", USERDATA="userdata", ["userdata"]="userdata", }, ENUM_ELEMENT_TYPE={ INDEXED=1, MIXED=2 } } instance.glass=Glu.glass setmetatable(instance, Glu)if table.size(registeredGlasses)==0 then local function detectModules(module_path, require_path)local filter="glu.lua" for file in lfs.dir(module_path)do if file:match("%.lua$")and file ~=filter then local module_name=file:match("^(.-)%.lua$")local require_file=string.format("%s/%s", require_path, module_name)assert(type(module_name)=="string", "Module name must be a string")assert(type(require_file)=="string", "Module file must be a string")require(require_file)end end end local pkg_path=getMudletHomeDir().. "/" .. pkg local module_path=pkg_path .. "/" .. module_dir_name local require_path=pkg .. "/" .. module_dir_name assert(type(module_dir_name)=="string", "Module directory name must be a string")assert(lfs.attributes(pkg_path), "Package directory " .. pkg .. " does not exist")assert(lfs.attributes(module_path), "Module directory " .. module_dir_name .. " does not exist in package " .. pkg)detectModules(module_path, require_path)end assert(table.size(registeredGlasses)>0, "No modules found in " .. pkg)function instance.getPackageName()return instance.package_name end function instance.hasObject(name)return instance.getObject(name)~=nil end function instance.getObject(name)return instance[name] and type(instance[name])=="table" and instance[name] or nil end for _, class in ipairs(registeredGlasses)do instance[class.name]={} end for _, class in ipairs(registeredGlasses)do local instance_opts={ name=class.name } newObject(instance, class, instance_opts, instance)end local handler_name="glu_sysUninstall_" .. Glu.id()instance.handler_name=handler_name registerNamedEventHandler("glu", handler_name, "sysUninstall", function(event, p)if p==instance.package_name then deleteNamedEventHandler("glu", handler_name)instance=nil end end)return instance end Glass={ name="glu_glass", class_name="Glass", inherit_from=nil, dependencies={}, register=function(class_opts)assert(type(class_opts)=="table", "opts must be a table")assert(type(class_opts.name)=="string", "`name` must be a string")assert(type(class_opts.class_name)=="string", "`class_name` must be a string")assert(type(class_opts.inherit_from)=="table" or class_opts.inherit_from==nil, "`inherit_from` must be a table or nil")assert(type(class_opts.setup)=="function", "`setup` must be a function")local name=class_opts.name local G=Glu.getGlass(name)if G then return G end G={ name=name, class_name=class_opts.class_name, inherit_from=class_opts.inherit_from, dependencies=class_opts.dependencies or {}, setup=class_opts.setup, } function G.new(instance_opts, container)assert(type(instance_opts)=="table", "`instance_opts` must be a table")assert(type(container)=="table", "`container` must be a table")local self={ inherit_from=class_opts.inherit_from, name=class_opts.name, class=class_opts.class_name, call=class_opts.call, container=container, objects={}, object=true, } self.__index=self if class_opts.inherit_from then local inherit_from_name=class_opts.inherit_from.name local parent_instance=container.objects[inherit_from_name] if not parent_instance then error("Instance of parent class `" .. inherit_from_name .. "` not found for `" .. class_opts.class_name .. "`")end self.parent=parent_instance if class_opts.call then self[class_opts.call]=parent_instance[class_opts.call] end setmetatable(self, { __index=parent_instance })else self.__index=self end local ___=self repeat ___=___.container until not ___.container self.___=___ for _, dep in ipairs(class_opts.dependencies or {})do local obj=___[dep] if not obj then error("Object `" .. dep .. "` not found for `" .. class_opts.class_name .. "`")end end local instance_name=instance_opts.name or ___.id()self.name=instance_name container.objects[instance_name]=self if table.index_of(table.keys(G), "setup")and type(G.setup)=="function" then G.setup(___, self, instance_opts, container)end assert(type(class_opts.call)=="string" or class_opts.call==nil, "`call` must be a string or nil")if class_opts.call then local mt=getmetatable(self)or {} mt.__call=function(_, ...)return self[class_opts.call](...)end setmetatable(self, mt)end return self end table.insert(registeredGlasses, G)setmetatable(G, { __index=class_opts.inherit_from or nil, __call=function(_, ...)return G.new(...)end })return G end } setmetatable(Glass, { __index=Glass, __call=function(_, ...)return Glass.new(...)end })Glu.glass=Glass end local ValidClass=Glu.glass.register({ name="valid", class_name="ValidClass", dependencies={ "table" }, setup=function(___, self)local trace_ignore=debug.getinfo(1).source local function get_last_traceback_line()local it, trace=1, "" while debug.getinfo(it)do if debug.getinfo(it).source ~=trace_ignore then local line=debug.getinfo(it).source .. ":" .. debug.getinfo(it).currentline trace=trace .. line .. "\n" end it=it+1 end if #trace==0 then return "[No traceback]" end return trace end function self.type(value, expected_type, argument_index, nil_allowed)local last=get_last_traceback_line()assert((nil_allowed==true and value==nil)or value ~=nil, "value must not be nil for argument " .. argument_index .. " in\n" .. last)assert(type(expected_type)=="string", "expected_type must be a string for argument " .. argument_index .. " in\n" .. last)assert(type(argument_index)=="number", "argument_index must be a number for argument " .. argument_index .. " in\n" .. last)assert(nil==nil_allowed or type(nil_allowed)=="boolean", "nil_allowed must be a boolean for argument " .. argument_index .. " in\n" .. last)if nil_allowed and value==nil then return end if expected_type=="any" then return end local expected_types=string.split(expected_type, "|")or { expected_type } local invalid=table.n_filter(expected_types, function(t)return not ___.TYPE[t] end)if table.size(invalid)>0 then error("Invalid type to argument " .. argument_index .. ". Expected " .. table.concat(invalid, "|").. ", got " .. type(value).. " in\n" .. last)end for _, t in ipairs(expected_types)do if type(value)==t then return end end error("Invalid type to argument " .. argument_index .. ". Expected " .. expected_type .. ", got " .. type(value).. " in\n" .. last)end function self.type_or_nil(value, expected_type, argument_index, nil_allowed)self.type(value, expected_type, argument_index, nil_allowed)end function self.rgb_table(colour, argument_index, nil_allowed)local last=get_last_traceback_line()self.type(colour, "table", argument_index, nil_allowed)assert(#colour==3, "Invalid number of elements to argument " .. argument_index .. ". Expected 3, got " .. #colour .. " in\n" .. last)assert(type(colour[1])=="number", "Invalid type to argument " .. argument_index .. ". Expected number, got " .. type(colour[1]).. " in\n" .. last)assert(type(colour[2])=="number", "Invalid type to argument " .. argument_index .. ". Expected number, got " .. type(colour[2]).. " in\n" .. last)assert(type(colour[3])=="number", "Invalid type to argument " .. argument_index .. ". Expected number, got " .. type(colour[3]).. " in\n" .. last)assert(colour[1]>=0 and colour[1]<=255, "Invalid value to argument " .. argument_index .. ". Expected number between 0 and 255, got " .. colour[1] .. " in\n" .. last)assert(colour[2]>=0 and colour[2]<=255, "Invalid value to argument " .. argument_index .. ". Expected number between 0 and 255, got " .. colour[2] .. " in\n" .. last)assert(colour[3]>=0 and colour[3]<=255, "Invalid value to argument " .. argument_index .. ". Expected number between 0 and 255, got " .. colour[3] .. " in\n" .. last)end function self.colour_name(colour, argument_index, nil_allowed)if nil_allowed and colour==nil then return end local name=rex.match(colour, "<?([\\w_]+)>?")or colour self.rgb_table(color_table[name], argument_index, nil_allowed)end function self.not_empty(value, argument_index, nil_allowed)assert(type(value)=="table", "Invalid type to argument " .. argument_index .. ". Expected table, got " .. type(value).. " in\n" .. get_last_traceback_line())if nil_allowed and value==nil then return end local last=get_last_traceback_line()assert(not table.is_empty(value), "Invalid value to argument " .. argument_index .. ". Expected non-empty in\n" .. last)end function self.n_uniform(value, expected_type, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=get_last_traceback_line()assert(___.table.n_uniform(value, expected_type), "Invalid type to argument " .. argument_index .. ". Expected an indexed table of " .. expected_type .. " in\n" .. last)end function self.regex(value, pattern, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=get_last_traceback_line()assert(rex.match(value, pattern), "Invalid value to argument " .. argument_index .. ". Expected " .. pattern .. ", got " .. value .. " in\n" .. last)end function self.indexed(value, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=get_last_traceback_line()assert(___.table.indexed(value), "Invalid value to argument " .. argument_index .. ". Expected indexed table, got " .. type(value).. " in\n" .. last)end function self.associative(value, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=get_last_traceback_line()assert(___.table.associative(value), "Invalid value to argument " .. argument_index .. ". Expected associative table, got " .. type(value).. " in\n" .. last)end function self.test(statement, value, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=get_last_traceback_line()assert(statement, "Invalid value to argument " .. argument_index .. ". " .. tostring(value).. " in\n" .. last)end function self.same(one, two)local last=get_last_traceback_line()assert(one==two, "Invalid value to arguments. Expected 1 and 2 to be identical in\n" .. get_last_traceback_line())end function self.same_type(one, two)local last=get_last_traceback_line()assert(type(one)==type(two), "Invalid value to arguments. Expected 1 and 2 to be of the same type in\n" .. last)end function self.object(value, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=get_last_traceback_line()assert(___.table.object(value), "Invalid value to argument " .. argument_index .. ". Expected object, got " .. type(value).. " in\n" .. last)end function self.range(value, min, max, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=get_last_traceback_line()assert(value>=min and value<=max, "Invalid value to argument " .. argument_index .. ". Expected " .. min .. " to " .. max .. ", got " .. value .. " in\n" .. last)end function self.file(path, argument_index)self.type(path, "string", argument_index, false)self.type(argument_index, "number", 2, false)local attr=lfs.attributes(path)local last=get_last_traceback_line()assert(attr ~=nil and attr.mode=="file", "Invalid value. Expected file, got " .. path .. " in\n" .. last)end function self.dir(path, argument_index)self.type(path, "string", argument_index, false)self.type(argument_index, "number", 2, false)print("valid.dir", path, argument_index)local attr=lfs.attributes(path)local last=get_last_traceback_line()assert(attr ~=nil and attr.mode=="directory", "Invalid value. Expected directory, got " .. path .. " in\n" .. last)end end })local ColourClass=Glu.glass.register({ class_name="ColourClass", name="colour", dependencies={ "number","valid" }, setup=function(___, self)function self.interpolate(rgb1, rgb2, factor)___.valid.rgb_table(rgb1, 1, false)___.valid.rgb_table(rgb2, 2, false)___.valid.type(factor, "number", 3, false)___.valid.test(factor>=0 and factor<=100, factor, 3, "Invalid step " .. "value " .. factor .. " given. Step value must " .. "be between 0 and 100.")local r1, g1, b1=rgb1[1], rgb1[2], rgb1[3] local r2, g2, b2=rgb2[1], rgb2[2], rgb2[3] local r, g, b=math.floor(r1+(r2-r1)*factor+0.5), math.floor(g1+(g2-g1)*factor+0.5), math.floor(b1+(b2-b1)*factor+0.5)return { r, g, b } end function self.is_light(rgb)___.valid.rgb_table(rgb, 1, false)local r=rgb[1]/255 local g=rgb[2]/255 local b=rgb[3]/255 local luminance=0.2126*r+0.7152*g+0.0722*b return luminance>0.5 end function self.adjust_colour(rgb, amount, lighten)___.valid.rgb_table(rgb, 1, false)___.valid.type(amount, "number", 2, true)amount=___.number.clamp(amount or 30, 0, 255)local direction=lighten and 1 or-1 return { math.floor(___.number.clamp(rgb[1]+direction*amount, 0, 255)), math.floor(___.number.clamp(rgb[2]+direction*amount, 0, 255)), math.floor(___.number.clamp(rgb[3]+direction*amount, 0, 255))} end function self.lighten(rgb, amount)return self.adjust_colour(rgb, amount, true)end function self.darken(rgb, amount)return self.adjust_colour(rgb, amount, false)end function self.lighten_or_darken(rgb_colour, rgb_compare, amount)___.valid.type(amount, "number", 3, true)amount=amount or 85 local colour_is_light=self.is_light(rgb_colour)local compare_is_light=self.is_light(rgb_compare)if colour_is_light and compare_is_light then return self.darken(rgb_colour, amount)elseif not colour_is_light and not compare_is_light then return self.lighten(rgb_colour, amount)else return rgb_colour end end function self.complementary(rgb)___.valid.rgb_table(rgb, 1, false)return { 255-rgb[1], 255-rgb[2], 255-rgb[3] } end function self.grayscale(rgb)___.valid.rgb_table(rgb, 1, false)local gray=math.floor((rgb[1]+rgb[2]+rgb[3])/3+0.5)return { gray, gray, gray } end function self.adjust_saturation(rgb, factor)___.valid.rgb_table(rgb, 1, false)___.valid.type(factor, "number", 2, true)local gray=(rgb[1]+rgb[2]+rgb[3])/3 return { math.floor(gray+(rgb[1]-gray)*factor), math.floor(gray+(rgb[2]-gray)*factor), math.floor(gray+(rgb[3]-gray)*factor)} end function self.random()return { math.random(0, 255), math.random(0, 255), math.random(0, 255)} end function self.random_shade(rgb, range)___.valid.rgb_table(rgb, 1, false)___.valid.type(range, "number", 2, true)range=range or 50 local r=math.random(math.max(0, rgb[1]-range), math.min(255, rgb[1]+range))local g=math.random(math.max(0, rgb[2]-range), math.min(255, rgb[2]+range))local b=math.random(math.max(0, rgb[3]-range), math.min(255, rgb[3]+range))return { r, g, b } end function self.generate_triad(rgb)___.valid.rgb_table(rgb, 1, false)local angle=120 local h=(rgb[1]/255+angle/360)% 1 local s=0.8 local v=0.8 local h1=(h+1/3)% 1 local h2=(h-1/3)% 1 local rgb1={ math.floor(h1*255+0.5), math.floor(s*255+0.5), math.floor(v*255+0.5)} local rgb2={ math.floor(h2*255+0.5), math.floor(s*255+0.5), math.floor(v*255+0.5)} return { rgb1, rgb2 } end end })local DateClass=Glu.glass.register({ class_name="DateClass", name="date", dependencies={ "valid" }, setup=function(___, self, opts)function self.shms(seconds, as_string)___.valid.type(seconds, "number", 1, false)___.valid.type(as_string, "boolean", 2, true)local s=seconds or 0 local is_negative=s<0 s=math.abs(s)local hh=math.floor(s/(60*60))local mm=math.floor((s %(60*60))/60)local ss=s % 60 if is_negative then if ss>0 then ss=60-ss mm=mm+1 end if mm>0 then mm=60-mm hh=(hh==0)and 23 or(hh-1)else hh=(hh==0)and 23 or(hh-1)end end if as_string then local r={} if hh ~=0 then r[#r+1]=hh .. "h" end if mm ~=0 then r[#r+1]=mm .. "m" end if ss ~=0 then r[#r+1]=ss .. "s" end return table.concat(r, " ")or "0s" else local result_hours=string.format("%02d", hh)local result_minutes=string.format("%02d", mm)local result_seconds=string.format("%02d", ss)return result_hours, result_minutes, result_seconds end end end })local StringClass=Glu.glass.register({ name="string", class_name="StringClass", dependencies={ "table", "valid" }, setup=function(___, self)function self.capitalize(str)___.valid.type(str, "string", 1, false)assert(str ~="", "Expected a non-empty string")local result=str:gsub("^%l", string.upper)return result or str end function self.trim(str)___.valid.type(str, "string", 1, false)return str:match("^%s*(.-)%s*$")end function self.ltrim(str)___.valid.type(str, "string", 1, false)return str:match("^%s*(.-)$")end function self.rtrim(str)___.valid.type(str, "string", 1, false)return str:match("^.-%s*$")end function self.strip_linebreaks(str)___.valid.type(str, "string", 1, false)local result, found, subbed=rex.gsub(str, "[\\r\\n]", "")return result or str end function self.replace(str, pattern, replacement)___.valid.type(str, "string", 1, false)___.valid.type(pattern, "string", 2, false)___.valid.type(replacement, "string", 3, false)while string.find(str, pattern)do str=string.gsub(str, pattern, replacement)end return str end function self.split(str, delimiter)___.valid.type(str, "string", 1, false)___.valid.type(delimiter, "string", 2, true)local t={} if not delimiter then for c in str:gmatch(".")do table.insert(t, c)end else for part in str:gmatch("[^" .. delimiter .. "]+")do table.insert(t, part)end end return t end function self.walk(input, delimiter)___.valid.type(input, "string", 1, false)___.valid.type(delimiter, "string", 2, true)local data if type(input)=="string" then data=self.split(input, delimiter)else data=input end return ___.table.walk(data)end function self.explode(input, delimiter)if type(input)=="string" then return self.split(input, delimiter)elseif type(input)=="table" then return input end error("Input must be string or table")end end })local TableClass=Glu.glass.register({ name="table", class_name="TableClass", dependencies={ "valid" }, setup=function(___, self)function self.n_cast(...)if type(...)=="table" and self.indexed(...)then return ... end return { ... } end self.assure_indexed=self.n_cast function self.map(t, fn, ...)___.valid.type(t, "table", 1, false)___.valid.type(fn, "function", 2, false)local result={} for k, v in pairs(t)do result[k]=fn(k, v, ...)end return result end function self.values(t)___.valid.type(t, "table", 1, false)local result={} for _, v in pairs(t)do result[#result+1]=v end return result end function self.n_uniform(t, typ)___.valid.type(t, "table", 1, false)___.valid.not_empty(t, 1, false)___.valid.indexed(t, 1, false)___.valid.type(typ, "string", 2, true)typ=typ or type(t[1])for _, v in pairs(t)do if type(v)~=typ then return false end end return true end function self.n_distinct(t)___.valid.indexed(t, 1, false)local result, seen={}, {} for _, v in ipairs(t)do if not seen[v] then seen[v]=true result[#result+1]=v end end return result end function self.pop(t)___.valid.type(t, "table", 1, false)___.valid.indexed(t, 1, false)return table.remove(t, #t)end function self.push(t, v)___.valid.type(t, "table", 1, false)___.valid.type(v, "any", 2, false)___.valid.indexed(t, 1, false)table.insert(t, v)return #t end function self.unshift(t, v)___.valid.type(t, "table", 1, false)___.valid.type(v, "any", 2, false)___.valid.indexed(t, 1, false)table.insert(t, 1, v)return #t end function self.shift(t)___.valid.type(t, "table", 1, false)___.valid.indexed(t, 1, false)return table.remove(t, 1)end function self.allocate(source, spec)local spec_type=type(spec)___.valid.type(source, "table", 1, false)___.valid.not_empty(source, 1, false)___.valid.indexed(source, 1, false)if spec_type==___.TYPE.TABLE then ___.valid.indexed(spec, 2, false)assert(#source==#spec, "Expected source and spec to have the same number of elements")elseif spec_type==___.TYPE.FUNCTION then ___.valid.type(spec, "function", 2, false)end local result={} if spec_type==___.TYPE.TABLE then for i=1, #spec do result[source[i]]=spec[i] end elseif spec_type==___.TYPE.FUNCTION then for i=1, #source do result[source[i]]=spec(i, source[i])end else for i=1, #source do result[source[i]]=spec end end return result end function self.indexed(t)___.valid.type(t, "table", 1, false)local index=1 for k in pairs(t)do if k ~=index then return false end index=index+1 end return true end function self.associative(t)___.valid.type(t, "table", 1, false)for k, _ in pairs(t)do if type(k)~="number" or k % 1 ~=0 or k<=0 then return true end end return false end function self.reduce(t, fn, initial)___.valid.indexed(t, 1, false)___.valid.type(fn, "function", 2, false)___.valid.type(initial, "any", 3, false)local acc=initial for k, v in pairs(t)do acc=fn(acc, v, k)end return acc end function self.slice(t, start, stop)___.valid.indexed(t, 1, false)___.valid.type(start, "number", 2, false)___.valid.type(stop, "number", 3, true)___.valid.test(start>=1, 2, false)___.valid.test(table.size(t)>=start, 2, false)___.valid.test(stop and stop>=start, 3, true)if not stop then stop=#t end local result={} for i=start, stop do result[#result+1]=t[i] end return result end function self.remove(t, start, stop)___.valid.indexed(t, 1, false)___.valid.type(start, "number", 2, false)___.valid.type(stop, "number", 3, true)___.valid.test(start>=1, 2, false)___.valid.test(table.size(t)>=start, 2, false)___.valid.test(stop and stop>=start, 3, true)local snipped={} if not stop then stop=start end local count=stop-start+1 for i=1, count do table.insert(snipped, table.remove(t, start))end return t, snipped end function self.chunk(t, size)___.valid.indexed(t, 1, false)___.valid.type(size, "number", 2, false)local result={} for i=1, #t, size do result[#result+1]=mod.slice(___, t, i, i+size-1)end return result end function self.concat(tbl, ...)___.valid.indexed(tbl, 1, false)local args={ ... } for _, tbl_value in ipairs(args)do if type(tbl_value)=="table" then for _, value in ipairs(tbl_value)do table.insert(tbl, value)end else table.insert(tbl, tbl_value)end end return tbl end function self.drop(tbl, n)___.valid.indexed(tbl, 1, false)___.valid.type(n, "number", 2, false)___.valid.test(n>=1, 2, false)return self.slice(___, tbl, n+1)end function self.dropRight(tbl, n)___.valid.indexed(tbl, 1, false)___.valid.type(n, "number", 2, false)___.valid.test(n>=1, 2, false)return self.slice(___, tbl, 1, #tbl-n)end function self.fill(tbl, value, start, stop)___.valid.indexed(tbl, 1, false)___.valid.type(value, "any", 2, false)___.valid.type(start, "number", 3, true)___.valid.type(stop, "number", 4, true)___.valid.test(start and start>=1, value, 3, true)___.valid.test(stop and stop>=start, value, 4, true)for i=start or 1, stop or #tbl do tbl[i]=value end return tbl end function self.find(tbl, fn)___.valid.indexed(tbl, 1, false)___.valid.type(fn, "function", 2, false)for i=1, #tbl do if fn(i, tbl[i])then return i end end return nil end function self.findLast(tbl, fn)___.valid.indexed(tbl, 1, false)___.valid.type(fn, "function", 2, false)for i=#tbl, 1,-1 do if fn(i, tbl[i])then return i end end return nil end function self.flatten(tbl)___.valid.indexed(tbl, 1, false)local result={} for _, v in ipairs(tbl)do if type(v)=="table" then mod.concat(___, result, v)else table.insert(result, v)end end return result end function self.flattenDeep(tbl)___.valid.indexed(tbl, 1, false)local result={} for _, v in ipairs(tbl)do if type(v)=="table" then mod.concat(___, result, mod.flatten_deep(___, v))else table.insert(result, v)end end return result end function self.initial(tbl)___.valid.indexed(tbl, 1, false)return self.slice(___, tbl, 1, #tbl-1)end function self.pull(tbl, ...)___.valid.indexed(tbl, 1, false)local args={ ... } if #args==0 then return tbl end local removeSet={} for _, value in ipairs(args)do removeSet[value]=true end for i=#tbl, 1,-1 do if removeSet[tbl[i]] then table.remove(tbl, i)end end return tbl end function self.reverse(tbl)___.valid.indexed(tbl, 1, false)local len, midpoint=#tbl, math.floor(#tbl/2)for i=1, midpoint do tbl[i], tbl[len-i+1]=tbl[len-i+1], tbl[i] end return tbl end function self.uniq(tbl)___.valid.indexed(tbl, 1, false)local seen={} local writeIndex=1 for readIndex=1, #tbl do local value=tbl[readIndex] if not seen[value] then seen[value]=true tbl[writeIndex]=value writeIndex=writeIndex+1 end end for i=#tbl, writeIndex,-1 do tbl[i]=nil end return tbl end function self.unzip(tbl)___.valid.indexed(tbl, 1, false)local size_of_table=#tbl local size_of_elements=#tbl[1] for _, t in ipairs(tbl)do ___.valid.test(size_of_elements==#t, t, 1, false)end local num_new_sub_tables=size_of_elements local new_sub_table_size=size_of_table local result={} for i=1, num_new_sub_tables do result[i]={} end for _, source_table in ipairs(tbl)do for i, value in ipairs(source_table)do table.insert(result[i], value)end end return result end function self.newWeak(opt)___.valid.test(rex.match(opt, "^(k?v?|v?k?)$"), opt, 1, true)opt=opt or "v" return setmetatable({}, { __mode=opt })end function self.weak(tbl)___.valid.type(tbl, "table", 1, false)return getmetatable(tbl)and getmetatable(tbl).__mode ~=nil end function self.zip(...)local tbls={ ... } local results={} local size=#tbls[1] for _, t in ipairs(tbls)do ___.valid:test(size==#t, t, 1, false)end for i=1, size do results[i]={} for _, t in ipairs(tbls)do table.insert(results[i], t[i])end end return results end function self.includes(tbl, value)___.valid.indexed(tbl, 1, false)___.valid.type(value, "any", 2, false)return table.index_of(tbl, value)~=nil end local function collect_tables(tbl, inherited)___.valid.object(tbl, 1, false)___.valid.type(inherited, "boolean", 2, true)local visited={} local tables={} local function add_table(t)if not visited[t] then table.insert(tables, t)visited[t]=true end end add_table(tbl)if inherited then local mt=getmetatable(tbl)while mt and mt.__index do local inheritedTbl=mt.__index if type(inheritedTbl)=="table" then add_table(inheritedTbl)end mt=getmetatable(inheritedTbl)end end return tables end local function get_types(tbl, test)___.valid.type(tbl, "table", 1, false)___.valid.type(test, "function", 2, false)local keys=table.keys(tbl)keys=table.n_filter(keys, function(k)return test(tbl, k)end)or {} return keys end local function assemble_results(tables, test)local result={} for _, t in ipairs(tables)do local keys=get_types(t, test)or {} for _, k in ipairs(keys)do if not mod.includes(___, result, k)then table.insert(result, k)end end end return result end function self.functions(tbl, inherited)___.valid.object(tbl, 1, false)___.valid.type(inherited, "boolean", 2, true)local tables=collect_tables(tbl, inherited)or {} local test=function(t, k)return type(t[k])=="function" end return assemble_results(tables, test)end self.methods=self.functions function self.properties(tbl, inherited)___.valid.object(tbl, 1, false)___.valid.type(inherited, "boolean", 2, true)local tables=collect_tables(tbl, inherited)or {} local test=function(t, k)return type(t[k])~="function" end return assemble_results(tables, test)end function self.is_object(tbl)___.valid.type(tbl, "table", 1, false)return tbl.object==true end function self.add(tbl, value)___.valid.associative(tbl, 1, false)___.valid.associative(value, 2, false)for k, v in pairs(value)do tbl[k]=v end return tbl end function self.n_add(tbl1, tbl2, index)___.valid.indexed(tbl1, 1, false)___.valid.indexed(tbl2, 2, false)___.valid.range(index, 1, #tbl1+1, 3, true)index=index or #tbl1+1 for i=1, #tbl2 do table.insert(tbl1, index+i-1, tbl2[i])end return tbl1 end function self.walk(tbl)___.valid.indexed(tbl, 1, false)local i=0 return function()i=i+1 if tbl[i] then return i, tbl[i] end end end function self.inherits(caller, base_class)local current_instance=caller while current_instance do if current_instance==base_class then return true end current_instance=current_instance.parent end return false end function self.protect_function(object, function_name)___.valid.type(function_name, "string", 2, false)local original_function=object[function_name] ___.valid.type(original_function, "function", 2, false)object[function_name]=function(caller, ...)if self.inherits(caller, object)then return original_function(caller, ...)end error("Access denied: " .. function_name .. " is protected and can " .. "only be called by inheriting classes.")end end function self.protect_variable(object, var_name)___.valid.type(var_name, "string", 2, false)___.valid.type(object[var_name], "any", 2, false)local base_class=getmetatable(object)setmetatable(object, { __index=function(tbl, key)if key==var_name and not self.inherits(tbl, base_class)then error("Access denied: Variable '" .. var_name .. "' is protected and can only be accessed by inheriting classes.")end return rawget(tbl, key)end, __newindex=function(tbl, key, value)if key==var_name and not self.inherits(tbl, base_class)then error("Access denied: Variable '" .. var_name .. "' is protected and can only be modified by inheriting classes.")end rawset(tbl, key, value)end, })end end })local NumberClass=Glu.glass.register({ name="number", class_name="NumberClass", dependencies={ "table", "valid" }, setup=function(___, self)function self.round(num, digits)___.valid.type(num, "number", 1, false)___.valid.type(digits, "number", 2, true)digits=digits or 0 local mult=10 ^ digits return math.floor(num*mult+0.5)/mult end function self.clamp(num, min, max)___.valid.type(num, "number", 1, false)___.valid.type(min, "number", 2, false)___.valid.type(max, "number", 3, false)return math.max(min, math.min(num, max))end function self.lerp(a, b, t)___.valid.type(a, "number", 1, false)___.valid.type(b, "number", 2, false)___.valid.type(t, "number", 3, false)___.valid.test(t>=0 and t<=1, t, 3, false, "Interpolation factor should be between 0 and 1")return a+(b-a)*t end function self.map(value, in_min, in_max, out_min, out_max)___.valid.type(value, "number", 1, false)___.valid.type(in_min, "number", 2, false)___.valid.type(in_max, "number", 3, false)___.valid.type(out_min, "number", 4, false)___.valid.type(out_max, "number", 5, false)return(value-in_min)*(out_max-out_min)/(in_max-in_min)+out_min end function self.sign(num)___.valid.type(num, "number", 1, false)if num>0 then return 1 elseif num<0 then return-1 else return 0 end end function self.is_approximate(a, b, percent_tolerance)___.valid.type(a, "number", 1, false)___.valid.type(b, "number", 2, false)___.valid.type(percent_tolerance, "number", 3, true)percent_tolerance=percent_tolerance or 5 local tolerance=math.abs(a)*(percent_tolerance/100)return math.abs(a-b)<=tolerance end function self.min(...)local args=___.table.n_cast(...)local values if #args==1 and type(args[1])=="table" then values=args[1] elseif #args>1 then values=args else error("Invalid argument type: expected a table or multiple numbers")end ___.valid.n_uniform(values, "number", 1, false)local result=math.huge for _, num in ipairs(values)do result=math.min(result, num)end return result end function self.max(...)local args=___.table.n_cast(...)local values if #args==1 and type(args[1])=="table" then values=args[1] elseif #args>1 then values=args else error("Invalid argument type: expected a table or multiple numbers")end ___.valid.n_uniform(values, "number", 1, false)local result=-math.huge for _, num in ipairs(values)do result=math.max(result, num)end return result end function self.sum(...)local args=___.table.n_cast(...)___.valid.n_uniform(args, "number", 1, false)return ___.table.n_reduce(args, function(acc, num)return acc+num end, 0)end end })local TimerClass=Glu.glass.register({ name="timer", class_name="TimerClass", dependencies={ "table", "valid" }, setup=function(___, self)self.multi_timers={} local function perform_multi_timer_function(name)local timer_function=mod.multi_timers[name] if not timer_function then return false end local defs=timer_function.def local def=defs[1] local ok, result=pcall(def.func, def.args)if not ok then return false end table.remove(defs, 1)if #defs>0 then local result2=___.timer.multi(name, defs)if not result2 then return false end else ___.timer.kill_multi(name)end return true end function self.multi(name, def, delay)___.valid.type(name, "string", 1, false)___.valid.not_empty(def, 2, false)___.valid.type(delay, "number", 3, true)if delay then def=___.table.map(def, function(_, element)element.delay=delay return element end)end self.multi_timers[name]={ def=def } local timer_result local timer_id=tempTimer(def[1].delay, function()timer_result=perform_multi_timer_function(name)end)if not timer_id then ___.timer.kill_multi(name)return false end self.multi_timers[name].id=timer_id return true end function self.kill_multi(name)___.valid.type(name, "string", 1, false)local timer_function=self.multi_timers[name] if not timer_function then return nil end self.multi_timers[name]=nil local id=timer_function.id if id then return killTimer(id)end return true end end })local RegexClass=Glu.glass.register({ name="regex", class_name="RegexClass", dependencies={}, setup=function(___, self)self.http_url="^(https?:\\/\\/)((([A-Za-z0-9-]+\\.)+[A-Za-z]{2,})|localhost)(:\\d+)?(\\/[^\\s]*)?$" end })local UrlClass=Glu.glass.register({ name="url", class_name="UrlClass", dependencies={ "table", "valid" }, setup=function(___, self)function self.decode(str)___.valid.type(str, "string", 1, false)str=(string.gsub(str, '+', ' ')or str)str=(string.gsub(str, '%%(%x%x)', function(h)return string.char(tonumber(h, 16))end)or str)return str end function self.encode(str)___.valid.type(str, "string", 1, false)str=(string.gsub(str, "([^%w])", function(c)return string.format("%%%02X", string.byte(c))end)or str)return str end function self.decode_params(query_string)local params={} for key_value in rex.gmatch(query_string, "([^&]+)")do local key, value=rex.match(key_value, "([^=]+)=([^=]+)")if key and value then params[self.decode(key)]=self.decode(value)end end return params end function self.encode_params(params)local encoded={} for key, value in pairs(params)do table.insert(encoded, self.encode(key).. "=" .. self.encode(value))end return table.concat(encoded, "&")or "" end function self.parse(url)___.valid.type(url, "string", 1, false)local protocol, host, port, path, query_string=rex.match(url, "^(https?)://([^/:]+)(?::(\\d+))?/([^?]*)\\??(.*)")local file=(rex.match(path, "([^/]+)$")or path)local params=self.decode_params(query_string or "")protocol=protocol and protocol or "http" port=port and tonumber(port)or protocol and(protocol=="http" and 80 or 443)local parsed={ protocol=protocol, host=host, port=port, path=path, file=file, params=params } return parsed end end })local VersionClass=Glu.glass.register({ name="version", class_name="VersionClass", dependencies={ "table", "valid" }, setup=function(___, self)local function _compare(one, two)if one==two then return 0 end if type(one)=="number" then return one<two and-1 or 1 elseif type(one)=="string" then return one<two and-1 or 1 end return one<two and-1 or 1 end function self.compare(version1, version2)___.valid.test(type(version1)=="string" or type(version1)=="number", 1, "Invalid value to argument 1. Expected a string or number.")___.valid.test(type(version2)=="string" or type(version2)=="number", 2, "Invalid value to argument 2. Expected a string or number.")___.valid.same_type(version1, version2)version1=tostring(version1)version2=tostring(version2)local version1_parts=version1:split("%.")or {} local version2_parts=version2:split("%.")or {} ___.valid.test(type(version1_parts)=="table", 1, "Invalid value to argument 1. Expected a string.")___.valid.test(type(version2_parts)=="table", 2, "Invalid value to argument 2. Expected a string.")___.valid.test(#version1_parts==#version2_parts, 1, "Invalid value to arguments. Expected 1 and 2 to have the same number of parts.")for i=1, #version1_parts do local result=_compare(version1_parts[i], version2_parts[i])if result ~=0 then return result end end return 0 end end })local QueueStack=Glu.glass.register({ name="queue_stack", class_name="QueueStackClass", dependencies={ "table", "valid" }, setup=function(___, self, opts, container)if not opts.funcs then return end local funcs=opts.funcs or {} funcs=___.table.n_cast(funcs)___.valid:n_uniform(funcs, "function", 2, false)self.stack=funcs self.id=___.id()function self.push(f)___.valid.type(f, "function", 1, false)return ___.table.push(self.stack, f)end function self.shift()return ___.table.shift(self.stack)end function self.execute(...)local task=self.shift()if not task then return self, nil end local result={ task(self, ...)} local count=#self.stack return self, count>0 and count or nil, unpack(result)end end })local QueueClass=Glu.glass.register({ name="queue", class_name="QueueClass", dependencies={ "table", "valid" }, setup=function(___, self)self.queues={} function self.new(funcs)___.valid.type(funcs, "table", 1, true)___.valid:n_uniform(funcs, "function", 1, false)funcs=funcs or {} local queue=QueueStack(funcs, self)___.table.push(self.queues, queue)return queue end function self.get(id)___.valid.type(id, "string", 1, false)for _, q in pairs(self.queues)do if q.id==id then return q end end return nil, f"Queue not found for id `{id}`." end function self.push(id, f)___.valid.type(id, "string", 1, false)___.valid.type(f, "function", 2, false)local q, err=self:get(id)if not q then return nil, err end return q.push(f)end function self.shift(id)___.valid.type(id, "string", 1, false)local q, err=self.get(id)if not q then return nil, err end return q.shift()end end })local SameClass=Glu.glass.register({ name="same", class_name="SameClass", dependencies={ "table", "valid" }, setup=function(___, self)function self.value_zero(value1, value2)___.valid.type(value1, "any", 1, false)___.valid.type(value2, "any", 2, false)if type(value1)~=type(value2)then return false end if type(value1)=="number" then if value1 ~=value1 and value2 ~=value2 then return true elseif value1==0 and value2==0 then return true elseif value1==value2 then return true else return false end end return value1==value2 end function self.value(value1, value2)___.valid.type(value1, "any", 1, false)___.valid.type(value2, "any", 2, false)if type(value1)~=type(value2)then return false end if type(value1)=="number" then if value1 ~=value1 and value2 ~=value2 then return true elseif value1==0 and value2==0 then return 1/value1==1/value2 elseif value1==value2 then return true else return false end end return value1==value2 end end })local FuncClass=Glu.glass.register({ name="func", class_name="FuncClass", dependencies={ "valid" }, setup=function(___, self)function self.delay(func, delay, ...)___.valid.type(func, "function", 1, false)___.valid.type(delay, "number", 2, false)return tempTimer(delay, function(...)func(...)end)end function self.wrap(func, wrapper)___.valid.type(func, "function", 1, false)___.valid.type(wrapper, "function", 2, false)return function(...)return wrapper(func, ...)end end function self.repeater(func, interval, times, ...)___.valid.type(func, "function", 1, false)___.valid.type(interval, "number", 2, true)___.valid.type(times, "number", 3, true)interval=interval or 1 times=times or 1 local count=0 local function _repeat(...)if count<times then func(...)count=count+1 tempTimer(interval, _repeat, ...)end end _repeat(...)end end })local TestRunnerClass=Glu.glass.register({ name="test_runner", class_name="TestRunnerClass", dependencies={ "table", "valid" }, setup=function(___, self, opts, owner)opts=opts or {} ___.table.add(self, { id=___.id(), tests={}, colours={ pass=(opts.colour and opts.colour.pass)or "<yellow_green>", fail=(opts.colour and opts.colour.fail)or "<orange_red>", }, symbols={ pass=(opts.symbol and opts.symbol.pass)or utf8.escape("%x{2714}"), fail=(opts.symbol and opts.symbol.fail)or utf8.escape("%x{2718}"), }, })___.valid.colour_name(self.colours.pass, 2, false)___.valid.colour_name(self.colours.fail, 2, false)local cond=___.conditions local default={ tests={} } local resets={ passes=0, fails=0, total=0 } function self.add(name, test)table.insert(self.tests, { name=name, test=test, passes=0, fails=0, total=0, runner=self, })return self end function self.remove(name)for i, test in ipairs(self.tests)do if test.name==name then table.remove(self.tests, i)return self end end error(f "Test '{name}' not found")end if opts.tests then repeat local name, test=unpack(___.table.values(table.remove(opts.tests, 1)))self.add(name, test)until table.size(opts.tests)==0 end function self.print()for _, test in ipairs(self.tests)do cecho(f"<b>{test.name}<r>\n")end return self end function self.reset()for k, v in pairs(resets)do for _, test in ipairs(self.tests)do test[k]=v end end return self end function self.wipe()for _, v in pairs(self.tests)do v=nil end return self end function self.pass(test)test.total=test.total+1 test.passes=test.passes+1 end function self.fail(test)test.total=test.total+1 test.fails=test.fails+1 end function self.execute(reset_when_done)reset_when_done=reset_when_done or false self.reset()for _, t in ipairs(self.tests)do local status_message=f"<light_goldenrod>Running test '{t.name}' " .. "(<r><seashell>%d<r><light_goldenrod>): " local success, result, fail_message=(function(test, condition)registerNamedEventHandler(test.name, test.name, "condition_is", function(_, c)if c==true then self.pass(test)elseif c==false then self.fail(test)else error(f"Expected a boolean, got {c}")end end)local success, result, fail_message=pcall(test.test, condition, self, test)deleteNamedEventHandler(test.name, test.name)return success, result, fail_message end)(t, cond)if not success or not result then if not success then self.fail(t)end status_message=status_message .. self.colours.fail .. self.symbols.fail .. "\n" .. " " .. self.colours.fail .. "Error in test '" .. t.name .. "':\n" .. " " .. tostring(result or fail_message).. "\n" else self.pass(t)status_message=status_message .. self.colours.pass .. self.symbols.pass .. "\n" end status_message=string.format(status_message, t.total)cecho(status_message)end owner.summary(self)if reset_when_done then self.reset()end return self end end })local TestClass=Glu.glass.register({ name="test", class_name="TestClass", dependencies={ "table", "valid" }, setup=function(___, self)local testers={} function self.runner(opts)local runner=TestRunnerClass(opts, self)testers[runner.id]=runner return runner end local function sum(tests)local result=0 for _, test in ipairs(tests)do result=result+test end return result end local function sum_field(tbls, field)local totals={} for _, tbl in ipairs(tbls)do table.insert(totals, tbl[field])end return sum(totals)end function self.summary(runner)local good_colour, bad_colour=unpack(___.table.values(runner.colours))local total_run=sum_field(runner.tests, "total")local total_success=sum_field(runner.tests, "success")local total_failure=sum_field(runner.tests, "failure")print("")cecho("<b>Tests run:</b><gold>" .. total_run .. "<r>\n")cecho("<b>Successes:</b>" .. good_colour .. total_success .. "<r>\n")cecho("<b>Failures:</b>" .. bad_colour .. total_failure .. "<r>\n")end return self end })local FinallyClass=Glu.glass.register({ class_name="FinallyClass", name="finally", inherit_from=nil, call="finally", setup=function(___, self, opts)function self.finally(f, ...)local success, result=pcall(f, { success=opts.catch.success, error=opts.catch.err, original_error=opts.try.err })if not success then print("Error in finally block:", result)end return self end return self end })local CatchClass=Glu.glass.register({ class_name="CatchClass", name="catch", inherit_from=nil, call="catch", setup=function(___, self, opts)function self.catch(f, ...)if opts.try.success then return FinallyClass({ catch={ success=true, err=nil }, try=opts.try }, self)end local success, result=pcall(f, opts.try.err)return FinallyClass({ catch={ success=success, err=result }, try=opts.try }, self)end return self end })local TryClass=Glu.glass.register({ class_name="TryClass", name="try", inherit_from=nil, dependencies={}, call="try", setup=function(___, self, opts)function self.try(f, ...)local args={ ... } local success, result=pcall(function()return f(unpack(args))end)return CatchClass({ try={ success=success, err=result, result=success and result or nil } }, self)end return self end })local FileSystemObjectClass=Glu.glass.register({ class_name="FileSystemObjectClass", name="file_system_object", dependencies={ "table", "valid" }, setup=function(___, self, opts, container)if not opts then return end ___.table.add(self, { type="file_system_object", })function self:set_type(type)self.type=type return self end function self:get_type()return self.type end ___.table.protect_function(self, "set_type")___.table.protect_variable(self, "type")end })local FileClass=Glu.glass.register({ class_name="FileClass", name="file", inherit_from=FileSystemObjectClass, dependencies={}, setup=function(___, self, opts, container)self:set_type("file")if not opts then return end if not opts.path then return end ___.valid.file(opts.path, 1)self.path=opts.path end })local DirectoryClass=Glu.glass.register({ class_name="DirectoryClass", name="directory", inherit_from=FileSystemObjectClass, dependencies={}, setup=function(___, self, opts, container)self:set_type("directory")if not opts then return end if not opts.path then return end ___.valid.dir(opts.path, 1)self.path=opts.path end })local FdClass=Glu.glass.register({ class_name="FdClass", name="fd", dependencies={ "table", "valid" }, setup=function(___, self)function self.dir_file(path, dir_required)___.valid.type(path, "string", 1, false)___.valid.type(dir_required, "boolean", 2, true)dir_required=dir_required or false path, _=self.fix_path(path)local dir, file=rex.match(path, "^(.*)/(.*)$")if #{dir, file}==2 then return dir, file end if dir_required and dir then if not self.dir_exists(dir)then return nil, nil end end return dir, file end function self.root_dir_file(path)___.valid.type(path, "string", 1, false)local root=self.determine_root(path)if not root then return nil, nil end local len=utf8.len(root)local dir, file=self.dir_file(path:sub(len+1))if not dir then return nil, nil end return root, dir, file end function self.file_exists(path)___.valid.type(path, "string", 1, false)local attr, message, code=lfs.attributes(path)if not attr then return false end return attr.mode=="file" end function self.dir_exists(path)___.valid.type(path, "string", 1, false)local attr, message, code=lfs.attributes(path)if not attr then return false end return attr.mode=="directory" end function self.read_file(path, binary)___.valid.type(path, "string", 1, false)___.valid.type(binary, "boolean", 2, true)local handle, error, code=io.open(path, "r" ..(binary and "b" or ""))if not handle then return nil, error, code end local data=handle:read("*a")handle:close()return data end function self.write_file(path, data, overwrite, binary)___.valid.type(path, "string", 1, false)___.valid.type(data, "string", 2, false)___.valid.type(overwrite, "boolean", 3, true)___.valid.type(binary, "boolean", 4, true)path=self.fix_path(path)local flag=overwrite and "w" or "a" local mode=binary and "b" or "" local handle, error, code=io.open(path, flag .. mode)if not handle then return nil, { error=error, code=code } end handle:write(data)handle:flush()handle:close()return path, lfs.attributes(path)end function self.fix_path(path)___.valid.type(path, "string", 1, false)local result, num=rex.gsub(rex.gsub(path, "\\\\", "/"), "//", "/")if not result or num==0 then return path, 0 end if result:sub(-1)=="/" then result=result:sub(1,-2)or "" end return result, num end function self.assure_dir(path)___.valid.type(path, "string", 1, false)path=self.fix_path(path)print(path)local root root, path, _=self.root_dir_file(path)if path[1]=="/" then path=path:sub(2)end local dirs=path:split("/")local target=root dirs=table.n_filter(dirs, function(dir)return dir ~="" end)local created={} repeat local dir=table.remove(dirs, 1)target=target .. "/" .. dir if not self.dir_exists(target)then local ok, err, code=lfs.mkdir(target)if not ok then return nil, err, code end table.insert(created, target)end until #dirs==0 created=___.table.map(created, function(_, dir)return self.fix_path(dir)end)return created, nil, nil end function self.determine_root(path)___.valid.type(path, "string", 1, false)path, _=self.fix_path(path)local parts={rex.match(path, "^([a-zA-Z]:(\\\\{1,2}|/{1,2})|/{1,2})(?:.*)$")} if not parts then return nil end local root, slash=parts[1], parts[2] or "" return root end function self.rmfile(path)___.valid.file(path, 1)return os.remove(path)end function self.rmdir(path)___.valid.dir(path, 1)return lfs.rmdir(path)end function self.dir_empty(path)return #self.get_dir(path, false)==0 end function self.get_dir(path, include_dots)___.valid.type(path, "string", 1, false)___.valid.type(include_dots, "boolean", 2, true)include_dots=include_dots or false path, _=self.fix_path(path)path=path or "" ___.valid.dir(path, 1)local result={} for file in lfs.dir(path)do local attr=lfs.attributes(path .. "/" .. file)table.insert(result, file)end if not include_dots then result=table.n_filter(result, function(file)return file ~="." and file ~=".." end)end return result end function self.tree(path)___.valid.type(path, "string", 1, false)path, _=self.fix_path(path)___.valid.dir(path, 1)local function build_tree(current_path)local tree={} for entry in lfs.dir(current_path)do if entry ~="." and entry ~=".." then local full_path=current_path .. "/" .. entry local attr=lfs.attributes(full_path)if attr then if attr.mode=="directory" then tree[entry]=DirectoryClass({ path=full_path, attributes=attr })tree[entry].children=build_tree(full_path)elseif attr.mode=="file" then tree[entry]=FileClass({ path=full_path, attributes=attr })end end end end return tree end local root_name=path:match("^.*/(.*)")or path local tree={ [root_name]=DirectoryClass({ path=path })} tree[root_name].children=build_tree(path)return tree end function self.export_tree(tree)local function traverse(node)local exported={} for name, obj in pairs(node)do if type(obj)=="table" and obj.class_name=="DirectoryClass" then exported[name]=traverse(obj.children or {})elseif type(obj)=="table" and obj.class_name=="FileClass" then exported[name]="file" end end return exported end local root_name=next(tree)local exported_tree={} exported_tree[root_name]=traverse(tree[root_name].children or {})return exported_tree end end })local ConditionsClass=Glu.glass.register({ class_name="ConditionsClass", name="conditions", dependencies={}, setup=function(___, self)function self.is(condition, message)assert(type(condition)=="boolean", "Expected a boolean as the first argument")assert(type(message)=="string" or message==nil, "Expected a string or nil as the second argument")raiseEvent("condition_is", condition)return condition, condition and nil or message end function self.is_true(condition, message)return self.is(condition, message or "Expected condition to be true")end function self.is_false(condition, message)return self.is(not condition, message or "Expected condition to be false")end function self.is_nil(a, message)return self.is(a==nil, message or "Expected `{a}` to be nil")end function self.is_not_nil(a, message)return self.is(a ~=nil, message or "Expected `{a}` to not be nil")end function self.is_error(func, message, check)assert(type(func)=="function", "Expected a function as the first argument")assert(type(message)=="string" or message==nil, "Expected a string or nil as the second argument")assert(type(check)=="function" or check==nil, "Expected a function or nil as the third argument")local test_success, test_err=pcall(func)local error_success, error_err if not test_success then if(check)then error_success, error_err=pcall(check, test_err, self)else error_success, error_err=true, nil end end return self.is(not error_success, message or f "Expected function to throw an error but it did not. Error: {error_err}")end function self.is_eq(a, b, message)return self.is(a==b, message or f "Expected `{a}` to equal `{b}`\n")end function self.is_ne(a, b, message)return self.is(a ~=b, message or f "Expected `{a}` to not equal `{b}`\n")end function self.is_lt(a, b, message)return self.is(a<b, message or f "Expected `{a}` to be less than `{b}`\n")end function self.is_le(a, b, message)return self.is(a<=b, message or f "Expected `{a}` to be less than or equal to `{b}`\n")end function self.is_gt(a, b, message)return self.is(a>b, message or f "Expected `{a}` to be greater than `{b}`\n")end function self.is_ge(a, b, message)return self.is(a>=b, message or f "Expected `{a}` to be greater than or equal to `{b}`\n")end function self.is_type(a, b, message)return self.is(type(a)==b, message or f "Expected `{a}` to be of type `{b}`\n")end function self.is_deeply(a, b, message)local result, mess local function deep_compare(first, second, visited)visited=visited or {} if type(first)~="table" or type(second)~="table" then result, mess=self.is_eq(first, second, message or f "Expected `{first}` to equal `{second}`")return result, result and nil or mess end for v1, v2 in pairs(visited)do if v1==first and v2==second then return true end end visited[first]=second for k, v in pairs(first)do if second[k]==nil then return false, f "Key `{k}` missing in second table" end local equal, err=deep_compare(v, second[k], visited)if not equal then return false, err end end for k in pairs(second)do if first[k]==nil then return false, f "Extra key `{k}` in second table" end end return true end return deep_compare(a, b, {})end end })
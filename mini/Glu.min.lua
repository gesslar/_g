if not _G["Glu"] then Glu={} Glu.__index=Glu table.unpack=table.unpack or unpack local registeredGlasses={} function Glu.get_glasses()return registeredGlasses end function Glu.get_glass_names()local names={} local glasses=Glu.get_glasses()for _, glass in ipairs(glasses or {})do table.insert(names, glass.name)end return names end function Glu.get_glass(name)for _, glass in ipairs(Glu.get_glasses())do if glass.name==name then return glass end end return nil end function Glu.has_glass(name)return Glu.get_glass(name)~=nil end function Glu.id()local function random_hex(length)return string.format("%0" .. length .. "x", math.random(0, 16 ^ length-1))end local result=string.format("%s%s-%s-4%s-%x%s-%s%s%s", random_hex(4), random_hex(4), random_hex(4), random_hex(3), 8+math.random(0, 3), random_hex(3), random_hex(4), random_hex(4), random_hex(4))return result end setmetatable(Glu, { __call=function(_, ...)return Glu.new(...)end })local function new_object(glu_instance, glass, instance_opts, container)instance_opts=instance_opts or {} container=container or glu_instance local function check_index_for_loop(ob)local seen={} local current=ob while current do if seen[current] then error(">>[newObject] Loop detected in __index chain for: " .. ob.name)end seen[current]=true current=getmetatable(current)and getmetatable(current).__index end return false end local function copy_properties(glu_class, into)local object=into[glu_class.name] for k, v in pairs(object)do glu_instance[glu_class.name][k]=v end local meta=getmetatable(object)if meta then setmetatable(glu_instance[glu_class.name], meta)end end local function instantiate(glu, glu_class, ops, into)if check_index_for_loop(glu_class)then return end if glu_class.inherit_from then local parent_name=glu_class.inherit_from local parent=into.get_object(parent_name)if not parent or(parent.glass and parent.glass.setup)then local parent_class=glu.get_glass(parent_name)return instantiate(glu, parent_class, ops, into)end end if not glu[glu_class.name] or table.index_of(table.keys(glu[glu_class.name]), "name")==nil then local object=glu_class(ops, glu)into[glu_class.name]=object copy_properties(glu_class, into)return object end end return instantiate(glu_instance, glass, instance_opts, container)end function Glu.new(pkg, module_dir_name)assert(type(pkg)=="string", "Package name must be a string.")assert(type(module_dir_name)=="string" or module_dir_name==nil, "Module directory name must be a string or nil.")local instance={ name="Glu", package_name=pkg, module_dir_name=module_dir_name, objects={}, container=nil, TYPE={ BOOLEAN="boolean", ["boolean"]="boolean", FUNCTION="function", ["function"]="function", NIL="nil", ["nil"]="nil", NUMBER="number", ["number"]="number", STRING="string", ["string"]="string", TABLE="table", ["table"]="table", THREAD="thread", ["thread"]="thread", USERDATA="userdata", ["userdata"]="userdata", }, ENUM_ELEMENT_TYPE={ INDEXED=1, MIXED=2 } } instance.glass=Glu.glass setmetatable(instance, Glu)if table.size(registeredGlasses)==0 then local function detectModules(module_path, require_path)local filter="glu.lua" for file in lfs.dir(module_path)do if file:match("%.lua$")and file ~=filter then local module_name=file:match("^(.-)%.lua$")local require_file=string.format("%s/%s", require_path, module_name)assert(type(module_name)=="string", "Module name must be a string")assert(type(require_file)=="string", "Module file must be a string")require(require_file)end end end local pkg_path=getMudletHomeDir().. "/" .. pkg local module_path=pkg_path .. "/" .. module_dir_name local require_path=pkg .. "/" .. module_dir_name assert(type(module_dir_name)=="string", "Module directory name must be a string")assert(lfs.attributes(pkg_path), "Package directory " .. pkg .. " does not exist")assert(lfs.attributes(module_path), "Module directory " .. module_dir_name .. " does not exist in package " .. pkg)detect_modules(module_path, require_path)end assert(table.size(registeredGlasses)>0, "No modules found in " .. pkg)function instance.getPackageName()return instance.package_name end function instance.has_object(name)return instance.get_object(name)~=nil end function instance.get_object(name)return instance[name] and type(instance[name])=="table" and instance[name] or nil end local trace_ignore=debug.getinfo(1).source function instance.get_last_traceback_line()local it, trace=1, "" while debug.getinfo(it)do if debug.getinfo(it).source ~=trace_ignore then local line=debug.getinfo(it).source .. ":" .. debug.getinfo(it).currentline trace=trace .. line .. "\n" end it=it+1 end if #trace==0 then return "[No traceback]" end return trace end instance.v={ get_last_traceback_line=instance.get_last_traceback_line, test=function(statement, value, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=instance.get_last_traceback_line()assert(statement, "Invalid value to argument " .. argument_index .. ". " .. tostring(value).. " in\n" .. last)end, type=function(value, expected_type, argument_index, nil_allowed)local last=instance.get_last_traceback_line()assert((nil_allowed==true and value==nil)or value ~=nil, "value must not be nil for argument " .. argument_index .. " in\n" .. last)assert(type(expected_type)=="string", "expected_type must be a string for argument " .. argument_index .. " in\n" .. last)assert(type(argument_index)=="number", "argument_index must be a number for argument " .. argument_index .. " in\n" .. last)assert(nil==nil_allowed or type(nil_allowed)=="boolean", "nil_allowed must be a boolean for argument " .. argument_index .. " in\n" .. last)if nil_allowed and value==nil then return end if expected_type=="any" then return end local expected_types=string.split(expected_type, "|")or { expected_type } local invalid=table.n_filter(expected_types, function(t)return not instance.TYPE[t] end)if table.size(invalid)>0 then error("Invalid type to argument " .. argument_index .. ". Expected " .. table.concat(invalid, "|").. ", got " .. type(value).. " in\n" .. last)end for _, t in ipairs(expected_types)do if type(value)==t then return end end error("Invalid type to argument " .. argument_index .. ". Expected " .. expected_type .. ", got " .. type(value).. " in\n" .. last)end } for _, class in ipairs(registeredGlasses)do new_object(instance, class, {}, instance)end local handler_name="glu_sysUninstall_" .. Glu.id()instance.handler_name=handler_name registerNamedEventHandler("glu", handler_name, "sysUninstall", function(event, p)if p==instance.package_name then deleteNamedEventHandler("glu", handler_name)instance=nil end end)return instance end Glass={ name="glu_glass", class_name="Glass", inherit_from=nil, dependencies={}, protect=function(glass, self)local function protect_function(object, function_name)assert(type(object)=="table", "`object` must be a table")assert(type(function_name)=="string", "`function_name` must be a string")local original_function=object[function_name] assert(type(original_function)=="function", "`original_function` must be a function")object[function_name]=function(caller, ...)if self.inherits(object)then return original_function(caller, ...)end error("Access denied: " .. function_name .. " is protected and can " .. "only be called by inheriting classes.")end end local function protect_variable(object, var_name)assert(type(object)=="table", "`object` must be a table")assert(type(var_name)=="string", "`var_name` must be a string")assert(type(object[var_name])~="nil", "`object[var_name]` must not be nil")local base_class=getmetatable(object)setmetatable(object, { __index=function(tbl, key)if key==var_name and not self.inherits(tbl, base_class)then error("Access denied: Variable '" .. var_name .. "' is protected and can only be accessed by inheriting classes.")end return rawget(tbl, key)end, __newindex=function(tbl, key, value)if key==var_name and not self.inherits(tbl, base_class)then error("Access denied: Variable '" .. var_name .. "' is protected and can only be modified by inheriting classes.")end rawset(tbl, key, value)end, })end if glass.protected_functions then for _, function_name in ipairs(glass.protected_functions)do protect_function(self, function_name)end end if glass.protected_variables then for _, var_name in ipairs(glass.protected_variables)do protect_variable(self, var_name)end end end, register=function(class_opts)assert(type(class_opts)=="table", "opts must be a table")assert(type(class_opts.name)=="string", "`name` must be a string")assert(type(class_opts.class_name)=="string", "`class_name` must " .. "be a string")assert(type(class_opts.inherit_from)=="string" or class_opts.inherit_from==nil, "`inherit_from` must be a string or nil")assert(type(class_opts.setup)=="function", "`setup` must " .. "be a function")assert(type(class_opts.valid)=="function" or class_opts.valid==nil, "`valid` must be a function or nil")local name=class_opts.name local G=Glu.get_glass(name)if G then return G end G={ name=name, class_name=class_opts.class_name, inherit_from=class_opts.inherit_from, dependencies=class_opts.dependencies or {}, setup=class_opts.setup, valid=class_opts.valid, protected_functions=class_opts.protected_functions, protected_variables=class_opts.protected_variables, } function G.new(instance_opts, container)assert(type(instance_opts)=="table" or instance_opts==nil, "`instance_opts` must be " .. "a table or nil")assert(type(container)=="table", "`container` must be a table")local self={ inherit_from=class_opts.inherit_from, name=class_opts.name, class=class_opts.class_name, call=class_opts.call, container=container, objects={}, object=true, } self.__index=self local ___=self repeat ___=___.container until not ___.container self.___=___ if class_opts.inherit_from then local inherit_from=class_opts.inherit_from local parent_instance=___.get_object(inherit_from)if not parent_instance then error("Instance of parent class `" .. inherit_from .. "` not " .. "found for `" .. class_opts.class_name .. "`")end self.parent=parent_instance setmetatable(self, { __index=parent_instance })else self.__index=self end for _, dep in ipairs(class_opts.dependencies or {})do local obj=___[dep] if not obj then local glass=___.get_glass(dep)if not glass then error("Object `" .. dep .. "` not found for `" .. class_opts.class_name .. "`")else obj=new_object(___, glass, {}, ___.container)end end end local instance_name=self.name or ___.id()if G.valid and type(G.valid)=="function" then ___.v=___.v or {} local valid=G.valid(___, self)if valid then for valid_function_name, valid_function in pairs(valid)do ___.v[valid_function_name]=valid_function end end end container.objects[instance_name]=self if table.index_of(table.keys(G), "setup")and type(G.setup)=="function" then G.setup(___, self, instance_opts, container)end function self.inherits(base_class)local current_instance=self while current_instance do if current_instance==base_class then return true end current_instance=current_instance.parent end return false end ___.glass.protect(G, self)assert(type(self.call)=="string" or self.call==nil, "`call` must be a string or nil")if self.call then local mt=getmetatable(self)or {} mt.__call=function(_, ...)local args={ ... } return self[self.call](unpack(args))end setmetatable(self, mt)end return self end table.insert(registeredGlasses, G)setmetatable(G, { __index=class_opts.inherit_from or nil, __call=function(_, ...)return G.new(...)end })tempTimer(0, function()raiseEvent("Glu.Glass.Registered", G)end)return G end } setmetatable(Glass, { __index=Glass, __call=function(_, ...)return Glass.new(...)end })Glu.glass=Glass end local GlassLoaderClass=Glu.glass.register({ class_name="GlassLoaderClass", name="glass_loader", call="load_glass", dependencies={ "try" }, setup=function(___, self, instance_opts, container)function self.load_glass(opts)local path=opts.path local cb=opts.cb or opts.callback local execute=opts.execute local path_type=___.string.starts_with(path, "https?://")and "url" or "path" local tried=___ .try(function()local function load_glass_from_data(data)local f=loadstring(data)return f or false, "Failed to load glass from data" end local function done(result)if not result then return false, "Failed to load glass from path" end if execute then local load_result local load_try=___ .try(function()load_result=result()end).catch(function(catch_result)return false, "Failed to execute glass: " .. catch_result.try.error end)end return result end if not path then return false, "No file or url provided" end if path_type=="url" then local request=___.http.get({ url=path }, function(response)if response.result.error then return false, "Failed to load glass from url: " .. response.result.error end return done(load_glass_from_data(response.result.data))end)else local data, err, code=___.fd.read_file(path)if not data then return false, err end return done(load_glass_from_data(data))end end)if tried.caught then tried.catch(function(result)cb(nil, "Failed to load glass from " .. path_type .. ": " .. result.try.error)end)else cb(tried.result.result)end end end })local ConditionsClass=Glu.glass.register({ class_name="ConditionsClass", name="conditions", dependencies={}, setup=function(___, self)function self.is(condition, message)assert(type(condition)=="boolean", "Expected a boolean as the first argument")assert(type(message)=="string" or message==nil, "Expected a string or nil as the second argument")raiseEvent("condition_is", condition)return condition, condition and nil or message end function self.is_true(condition, message)return self.is(condition, message or "Expected condition to be true")end function self.is_false(condition, message)return self.is(not condition, message or "Expected condition to be false")end function self.is_nil(value, message)return self.is(value==nil, message or "Expected `{value}` to be nil")end function self.is_not_nil(value, message)return self.is(value ~=nil, message or "Expected `{value}` to not be nil")end function self.is_error(func, message, check)assert(type(func)=="function", "Expected a function as the first argument")assert(type(message)=="string" or message==nil, "Expected a string or nil as the second argument")assert(type(check)=="function" or check==nil, "Expected a function or nil as the third argument")local test_success, test_err=pcall(func)local error_success, error_err if not test_success then if(check)then error_success, error_err=pcall(check, test_err, self)else error_success, error_err=true, nil end end return self.is(not error_success, message or f "Expected function to throw an error but it did not. Error: {error_err}")end function self.is_eq(a, b, message)return self.is(a==b, message or f "Expected `{a}` to equal `{b}`\n")end function self.is_ne(a, b, message)return self.is(a ~=b, message or f "Expected `{a}` to not equal `{b}`\n")end function self.is_lt(a, b, message)return self.is(a<b, message or f "Expected `{a}` to be less than `{b}`\n")end function self.is_le(a, b, message)return self.is(a<=b, message or f "Expected `{a}` to be less than or equal to `{b}`\n")end function self.is_gt(a, b, message)return self.is(a>b, message or f "Expected `{a}` to be greater than `{b}`\n")end function self.is_ge(a, b, message)return self.is(a>=b, message or f "Expected `{a}` to be greater than or equal to `{b}`\n")end function self.is_type(value, type, message)return self.is(type(value)==type, message or f "Expected `{value}` to be of type `{type}`\n")end function self.is_deeply(a, b, message)local result, mess local function deep_compare(first, second, visited)visited=visited or {} if type(first)~="table" or type(second)~="table" then result, mess=self.is_eq(first, second, message or f "Expected `{first}` to equal `{second}`")return result, result and nil or mess end for v1, v2 in pairs(visited)do if v1==first and v2==second then return true end end visited[first]=second for k, v in pairs(first)do if second[k]==nil then return false, f "Key `{k}` missing in second table" end local equal, err=deep_compare(v, second[k], visited)if not equal then return false, err end end for k in pairs(second)do if first[k]==nil then return false, f "Extra key `{k}` in second table" end end return true end return deep_compare(a, b, {})end end })local ColourClass=Glu.glass.register({ class_name="ColourClass", name="colour", dependencies={ "number",}, setup=function(___, self)local v=self.v function self.interpolate(rgb1, rgb2, factor, method)___.v.rgb_table(rgb1, 1, false)___.v.rgb_table(rgb2, 2, false)___.v.type(factor, "number", 3, false)___.v.range(factor, 0, 100, 3, false)local lerps={ linear=___.number.lerp, smooth=___.number.lerp_smooth, smoother=___.number.lerp_smoother, ease_in=___.number.lerp_ease_in, ease_out=___.number.lerp_ease_out } method=method or 'smooth' local valid_methods=table.keys(lerps)local lerp_func=lerps[method] ___.v.test(lerp_func ~=nil, f"Invalid interpolation method: {method}. Must be one of: " .. table.concat(valid_methods, ", "), 4, false)local hsl1=self.rgb_to_hsl(rgb1)local hsl2=self.rgb_to_hsl(rgb2)local t=factor/100 local h1, h2=hsl1[1], hsl2[1] local diff=h2-h1 if diff>180 then h2=h2-360 elseif diff<-180 then h2=h2+360 end local h=lerp_func(h1, h2, t)% 360 local s=lerp_func(hsl1[2], hsl2[2], t)local l=lerp_func(hsl1[3], hsl2[3], t)return self.hsl_to_rgb({h, s, l})end function self.rgb_to_hsl(rgb)___.v.rgb_table(rgb, 1, false)local r, g, b=rgb[1]/255, rgb[2]/255, rgb[3]/255 local max, min=math.max(r, g, b), math.min(r, g, b)local h, s, l=0, 0,(max+min)/2 if max ~=min then local d=max-min s=l>0.5 and d/(2-max-min)or d/(max+min)if max==r then h=(g-b)/d+(g<b and 6 or 0)elseif max==g then h=(b-r)/d+2 else h=(r-g)/d+4 end h=h/6 end return { math.floor(h*360+0.5), math.floor(s*100+0.5), math.floor(l*100+0.5)} end function self.to_hex(rgb, include_background)___.v.rgb_table(rgb, 1, false)___.v.type(include_background, "boolean", 2, true)local function to_hex_part(r, g, b)return string.format("%02x%02x%02x", r, g, b)end if include_background then return "#" .. to_hex_part(rgb[1], rgb[2], rgb[3]).. "," .. to_hex_part(bg[1], bg[2], bg[3])else return "#" .. to_hex_part(rgb[1], rgb[2], rgb[3])end end function self.hsl_to_rgb(hsl)___.v.hsl_table(hsl, 1, false)local h, s, l=hsl[1]/360, hsl[2]/100, hsl[3]/100 local function hue_to_rgb(p, q, t)if t<0 then t=t+1 end if t>1 then t=t-1 end if t<1/6 then return p+(q-p)*6*t end if t<1/2 then return q end if t<2/3 then return p+(q-p)*(2/3-t)*6 end return p end local r, g, b if s==0 then r, g, b=l, l, l else local q=l<0.5 and l*(1+s)or l+s-l*s local p=2*l-q r=hue_to_rgb(p, q, h+1/3)g=hue_to_rgb(p, q, h)b=hue_to_rgb(p, q, h-1/3)end return { math.floor(r*255+0.5), math.floor(g*255+0.5), math.floor(b*255+0.5)} end function self.is_light(rgb)___.v.rgb_table(rgb, 1, false)local r=rgb[1]/255 local g=rgb[2]/255 local b=rgb[3]/255 local luminance=0.2126*r+0.7152*g+0.0722*b return luminance>0.5 end function self.adjust_colour(rgb, amount, lighten)___.v.rgb_table(rgb, 1, false)___.v.type(amount, "number", 2, true)amount=___.number.clamp(amount or 30, 0, 255)local direction=lighten and 1 or-1 return { math.floor(___.number.clamp(rgb[1]+direction*amount, 0, 255)), math.floor(___.number.clamp(rgb[2]+direction*amount, 0, 255)), math.floor(___.number.clamp(rgb[3]+direction*amount, 0, 255))} end function self.lighten(rgb, amount)return self.adjust_colour(rgb, amount, true)end function self.darken(rgb, amount)return self.adjust_colour(rgb, amount, false)end function self.lighten_or_darken(rgb_colour, rgb_compare, amount)___.v.type(amount, "number", 3, true)amount=amount or 85 local colour_is_light=self.is_light(rgb_colour)local compare_is_light=self.is_light(rgb_compare)if colour_is_light and compare_is_light then return self.darken(rgb_colour, amount)elseif not colour_is_light and not compare_is_light then return self.lighten(rgb_colour, amount)else return rgb_colour end end function self.complementary(rgb)___.v.rgb_table(rgb, 1, false)local hsl=self.rgb_to_hsl(rgb)hsl[1]=(hsl[1]+180)% 360 return self.hsl_to_rgb(hsl)end function self.grayscale(rgb)___.v.rgb_table(rgb, 1, false)local gray=math.floor((rgb[1]+rgb[2]+rgb[3])/3+0.5)return { gray, gray, gray } end function self.adjust_saturation(rgb, factor)___.v.rgb_table(rgb, 1, false)___.v.type(factor, "number", 2, true)local gray=(rgb[1]+rgb[2]+rgb[3])/3 return { math.floor(gray+(rgb[1]-gray)*factor), math.floor(gray+(rgb[2]-gray)*factor), math.floor(gray+(rgb[3]-gray)*factor)} end function self.random()return { math.random(0, 255), math.random(0, 255), math.random(0, 255)} end function self.random_shade(rgb, range)___.v.rgb_table(rgb, 1, false)___.v.type(range, "number", 2, true)range=range or 50 local r=math.random(math.max(0, rgb[1]-range), math.min(255, rgb[1]+range))local g=math.random(math.max(0, rgb[2]-range), math.min(255, rgb[2]+range))local b=math.random(math.max(0, rgb[3]-range), math.min(255, rgb[3]+range))return { r, g, b } end function self.triad(rgb)___.v.rgb_table(rgb, 1, false)local hsl=self.rgb_to_hsl(rgb)return { self.hsl_to_rgb({(hsl[1]+120)% 360, hsl[2], hsl[3] }), self.hsl_to_rgb({(hsl[1]+240)% 360, hsl[2], hsl[3] })} end function self.analogous(rgb, angle)___.v.rgb_table(rgb, 1, false)___.v.type(angle, "number", 2, true)angle=angle or 30 local hsl=self.rgb_to_hsl(rgb)return { self.hsl_to_rgb({(hsl[1]-angle)% 360, hsl[2], hsl[3] }), rgb, self.hsl_to_rgb({(hsl[1]+angle)% 360, hsl[2], hsl[3] })} end function self.split_complement(rgb, angle)___.v.rgb_table(rgb, 1, false)___.v.type(angle, "number", 2, true)angle=angle or 30 local hsl=self.rgb_to_hsl(rgb)local complement_h=(hsl[1]+180)% 360 return { self.hsl_to_rgb({(complement_h-angle)% 360, hsl[2], hsl[3] }), self.hsl_to_rgb({(complement_h+angle)% 360, hsl[2], hsl[3] })} end function self.monochrome(rgb, steps)___.v.rgb_table(rgb, 1, false)___.v.type(steps, "number", 2, true)steps=steps or 5 local hsl=self.rgb_to_hsl(rgb)local results={} for i=0, steps-1 do local s=___.number.clamp(hsl[2]+(i-(steps/2))*10, 0, 100)local l=___.number.clamp(hsl[3]+(i-(steps/2))*10, 0, 100)table.insert(results, self.hsl_to_rgb({ hsl[1], s, l }))end return results end function self.tetrad(rgb)___.v.rgb_table(rgb, 1, false)local hsl=self.rgb_to_hsl(rgb)return { rgb, self.hsl_to_rgb({(hsl[1]+90)% 360, hsl[2], hsl[3] }), self.hsl_to_rgb({(hsl[1]+180)% 360, hsl[2], hsl[3] }), self.hsl_to_rgb({(hsl[1]+270)% 360, hsl[2], hsl[3] })} end function self.contrast_ratio(rgb1, rgb2)___.v.rgb_table(rgb1, 1, false)___.v.rgb_table(rgb2, 2, false)local function luminance(rgb)local r, g, b=rgb[1]/255, rgb[2]/255, rgb[3]/255 r=r<=0.03928 and r/12.92 or((r+0.055)/1.055)^ 2.4 g=g<=0.03928 and g/12.92 or((g+0.055)/1.055)^ 2.4 b=b<=0.03928 and b/12.92 or((b+0.055)/1.055)^ 2.4 return 0.2126*r+0.7152*g+0.0722*b end local l1=luminance(rgb1)local l2=luminance(rgb2)local lighter=math.max(l1, l2)local darker=math.min(l1, l2)return(lighter+0.05)/(darker+0.05)end function self.contrast(rgb)___.v.rgb_table(rgb, 1, false)local hsl=self.rgb_to_hsl(rgb)hsl[3]=100-hsl[3] return self.hsl_to_rgb(hsl)end end, valid=function(___, self)return { rgb_table=function(colour, argument_index, nil_allowed)local last=___.v.get_last_traceback_line()___.v.type(colour, "table", argument_index, nil_allowed)assert(#colour==3, "Invalid number of elements to argument " .. argument_index .. ". Expected 3, got " .. #colour .. " in\n" .. last)assert(type(colour[1])=="number", "Invalid type to argument " .. argument_index .. ". Expected number, got " .. type(colour[1]).. " in\n" .. last)assert(type(colour[2])=="number", "Invalid type to argument " .. argument_index .. ". Expected number, got " .. type(colour[2]).. " in\n" .. last)assert(type(colour[3])=="number", "Invalid type to argument " .. argument_index .. ". Expected number, got " .. type(colour[3]).. " in\n" .. last)assert(colour[1]>=0 and colour[1]<=255, "Invalid value to argument " .. argument_index .. ". Expected number between 0 and 255, got " .. colour[1] .. " in\n" .. last)assert(colour[2]>=0 and colour[2]<=255, "Invalid value to argument " .. argument_index .. ". Expected number between 0 and 255, got " .. colour[2] .. " in\n" .. last)assert(colour[3]>=0 and colour[3]<=255, "Invalid value to argument " .. argument_index .. ". Expected number between 0 and 255, got " .. colour[3] .. " in\n" .. last)end, hsl_table=function(hsl, argument_index, nil_allowed)local last=___.v.get_last_traceback_line()___.v.type(hsl, "table", argument_index, nil_allowed)assert(#hsl==3, "Invalid number of elements to argument " .. argument_index .. ". Expected 3, got " .. #hsl .. " in\n" .. last)assert(type(hsl[1])=="number", "Invalid type to argument " .. argument_index .. ". Expected number for hue, got " .. type(hsl[1]).. " in\n" .. last)assert(type(hsl[2])=="number", "Invalid type to argument " .. argument_index .. ". Expected number for saturation, got " .. type(hsl[2]).. " in\n" .. last)assert(type(hsl[3])=="number", "Invalid type to argument " .. argument_index .. ". Expected number for lightness, got " .. type(hsl[3]).. " in\n" .. last)assert(hsl[1]>=0 and hsl[1]<=360, "Invalid value to argument " .. argument_index .. ". Expected hue between 0 and 360, got " .. hsl[1] .. " in\n" .. last)assert(hsl[2]>=0 and hsl[2]<=100, "Invalid value to argument " .. argument_index .. ". Expected saturation between 0 and 100, got " .. hsl[2] .. " in\n" .. last)assert(hsl[3]>=0 and hsl[3]<=100, "Invalid value to argument " .. argument_index .. ". Expected lightness between 0 and 100, got " .. hsl[3] .. " in\n" .. last)end, colour_name=function(colour, argument_index, nil_allowed)if nil_allowed and colour==nil then return end local name=rex.match(colour, "<?([\\w_]+)>?")or colour ___.v.rgb_table(color_table[name], argument_index, nil_allowed)end } end })local DateClass=Glu.glass.register({ class_name="DateClass", name="date", dependencies={}, setup=function(___, self, opts)local v=___.v function self.shms(seconds, as_string)v.type(seconds, "number", 1, false)v.type(as_string, "boolean", 2, true)local s=seconds or 0 local is_negative=s<0 s=math.abs(s)local hh=math.floor(s/(60*60))local mm=math.floor((s %(60*60))/60)local ss=s % 60 if is_negative then if ss>0 then ss=60-ss mm=mm+1 end if mm>0 then mm=60-mm hh=(hh==0)and 23 or(hh-1)else hh=(hh==0)and 23 or(hh-1)end end if as_string then local r={} if hh ~=0 then r[#r+1]=hh .. "h" end if mm ~=0 then r[#r+1]=mm .. "m" end if ss ~=0 then r[#r+1]=ss .. "s" end return table.concat(r, " ")or "0s" else local result_hours=string.format("%02d", hh)local result_minutes=string.format("%02d", mm)local result_seconds=string.format("%02d", ss)return result_hours, result_minutes, result_seconds end end end })local DependencyClass=Glu.glass.register({ class_name="DependencyClass", name="dependency", dependencies={ "queue", "table"}, setup=function(___, self)self.queues={} function self.new(packages, cb)local queue=___.dependency_queue.new(packages, cb)___.table.push(self.queues, queue)return queue end end })local DependencyQueueClass=Glu.glass.register({ class_name="DependencyQueueClass", name="dependency_queue", inherit_from="queue", call="new_dependency_queue", dependencies={"queue", "table",}, setup=function(___, self)function self.new_dependency_queue(packages, cb)local installed=getPackages()local not_installed=table.n_filter(packages, function(package)return ___.table.index_of(installed, package.name)==nil end)or {} if #not_installed==0 then cecho("All dependencies are already installed.\n")cb(true, nil)return end local id=___.id()___.table.add(self, { id=id, cb=cb, packages=not_installed, handler_name=f "dependency_{id}_installed", })for _, package in ipairs(not_installed)do self.push(self.id, function()cecho(f "Installing dependency `<b>{package.name}</b>`...\n")installPackage(package.url)end)end registerNamedEventHandler("glu", self.handler_name, "sysInstall", function(event, package)if package ~=self.packages[1].name then return end ___.table.shift(self.packages)tempTimer(1, function()local q, count=self.queue.execute()if #self.packages==0 then self.cb(true, nil)self.clean_up()end end)end)registerNamedEventHandler("glu", self.handler_name .. "_download_error", "sysDownloadError", function(event, package)self.cb(false, f "Failed to download dependency `<b>{package}</b>`.\nCleaning up.\n")self.clean_up()end)function self.clean_up()deleteNamedEventHandler("glu", self.handler_name)deleteNamedEventHandler("glu", self.handler_name .. "_download_error")self.handler_name=nil self.queue=nil end function self.start()self.execute()end end end })local FdClass=Glu.glass.register({ class_name="FdClass", name="fd", dependencies={ "table"}, setup=function(___, self)function self.dir_file(path, dir_required)___.v.type(path, "string", 1, false)___.v.type(dir_required, "boolean", 2, true)dir_required=dir_required or false path, _=self.fix_path(path)local dir, file=rex.match(path, "^(.*)/(.*)$")if #{dir, file}==2 then return dir, file end if dir_required and dir then if not self.dir_exists(dir)then return nil, nil end end return dir, file end function self.root_dir_file(path)___.v.type(path, "string", 1, false)local root=self.determine_root(path)if not root then return nil, nil, nil end local len=utf8.len(root)local dir, file=self.dir_file(path:sub(len+1))if not dir then return nil, nil, nil end return root, dir, file end function self.file_exists(path)___.v.type(path, "string", 1, false)local attr, message, code=lfs.attributes(path)if not attr then return false end return attr.mode=="file" end function self.dir_exists(path)___.v.type(path, "string", 1, false)local attr, message, code=lfs.attributes(path)if not attr then return false end return attr.mode=="directory" end function self.read_file(path, binary)___.v.type(path, "string", 1, false)___.v.type(binary, "boolean", 2, true)local handle, error, code=io.open(path, "r" ..(binary and "b" or ""))if not handle then return nil, error, code end local data=handle:read("*a")handle:close()return data end function self.write_file(path, data, overwrite, binary)___.v.type(path, "string", 1, false)___.v.type(data, "string", 2, false)___.v.type(overwrite, "boolean", 3, true)___.v.type(binary, "boolean", 4, true)path=self.fix_path(path)local flag=overwrite and "w" or "a" local mode=binary and "b" or "" local handle, error, code=io.open(path, flag .. mode)if not handle then return nil, { error=error, code=code } end handle:write(data)handle:flush()handle:close()return path, lfs.attributes(path)end function self.fix_path(path)___.v.type(path, "string", 1, false)local result, num=rex.gsub(rex.gsub(path, "\\\\", "/"), "//", "/")if not result or num==0 then return path, 0 end if result:sub(-1)=="/" then result=result:sub(1,-2)or "" end return result, num end function self.determine_path_separator(path)___.v.type(path, "string", 1, false)for _, sep in ipairs({ "/", "\\" })do if path:find(sep)then return sep end end return nil end function self.valid_path_string(path)___.v.type(path, "string", 1, false)return self.determine_path_separator(path)~=nil end function self.valid_path_table(paths)___.v.indexed(paths, "table", 1, false)return ___.table.all(paths, self.valid_path_string)end function self.valid_path_table_or_string(path)path=___.table.n_cast(path)___.v.indexed(path, "table", 1, false)if type(path)=="string" then return self.valid_path_string(path)elseif type(path)=="table" then return self.valid_path_table(path)end return false end function self.valid_path(path)___.v.type(path, "string", 1, false)return self.dir_exists(path)or self.file_exists(path)end function self.valid_paths(paths)___.v.n_uniform(paths, "string", 1, false)return ___.table.all(paths, self.valid_path)end function self.valid_path_table(paths)___.v.indexed(paths, "table", 1, false)return ___.table.all(paths, self.valid_path)end function self.assure_dir(path)___.v.type(path, "string", 1, false)local sep=self.determine_path_separator(path)path=self.fix_path(path)path=___.string.append(path, sep)local root root, path, _=self.root_dir_file(path)if path[1]==sep then path=path:sub(2)end local dirs=path:split(sep)local target=root dirs=table.n_filter(dirs, function(dir)return dir ~="" end)local created={} repeat local dir=table.remove(dirs, 1)target=___.string.append(target, dir).. sep if not self.dir_exists(target)then local ok, err, code=lfs.mkdir(target)if not ok and err and code ~=17 then return nil, err, code end table.insert(created, target)end until #dirs==0 created=___.table.map(created, function(_, dir)return self.fix_path(dir)end)return created, nil, nil end function self.determine_root(path)___.v.type(path, "string", 1, false)path, _=self.fix_path(path)local parts={rex.match(path, "^([a-zA-Z]:(\\\\{1,2}|/{1,2})|/{1,2})(?:.*)$")} if not parts then return nil end local root, slash=parts[1], parts[2] or "" return root end function self.rmfile(path)___.v.file(path, 1)return os.remove(path)end function self.rmdir(path)___.v.dir(path, 1)return lfs.rmdir(path)end function self.dir_empty(path)return #self.get_dir(path, false)==0 end function self.get_dir(path, include_dots)___.v.type(path, "string", 1, false)___.v.type(include_dots, "boolean", 2, true)include_dots=include_dots or false path, _=self.fix_path(path)path=path or "" ___.v.dir(path, 1)local result={} for file in lfs.dir(path)do local attr=lfs.attributes(path .. "/" .. file)table.insert(result, file)end if not include_dots then result=table.n_filter(result, function(file)return file ~="." and file ~=".." end)end return result end function self.temp_dir()local dir=getMudletHomeDir().. "/tmp/" .. ___.id()local ok, err, code=self.assure_dir(dir)if not ok then return nil, err, code end return dir end end, valid=function(___, self)return { file=function(path, argument_index)___.v.type(path, "string", argument_index, false)___.v.type(argument_index, "number", 2, false)local attr=lfs.attributes(path)local last=___.get_last_traceback_line()assert(attr ~=nil and attr.mode=="file", "Invalid value. " .. "Expected file, got " .. path .. " in\n" .. last)end, dir=function(path, argument_index)___.v.type(path, "string", argument_index, false)___.v.type(argument_index, "number", 2, false)local attr=lfs.attributes(path)local last=___.get_last_traceback_line()assert(attr ~=nil and attr.mode=="directory", "Invalid value. " .. "Expected directory, got " .. path .. " in\n" .. last)end, path_string=function(path, argument_index, allow_nil)___.v.type(path, "string", argument_index, false)___.v.type(argument_index, "number", 2, false)___.v.type(allow_nil, "boolean", 3, true)if allow_nil and path==nil then return end assert(self.valid_path_string(path), "Invalid value. " .. "Expected valid path string, got " .. path .. " in\n" .. ___.get_last_traceback_line())end, path_table=function(paths, argument_index, allow_nil)___.v.uniform(paths, "string", 1, false)___.v.type(allow_nil, "boolean", 2, true)allow_nil=allow_nil or false if allow_nil and #paths==0 then return end assert(self.valid_path_table(paths), "Invalid value. " .. "Expected valid path table, got " .. ___.table.to_string(paths).. " in\n" .. ___.get_last_traceback_line())end } end })local FuncClass=Glu.glass.register({ name="func", class_name="FuncClass", dependencies={}, setup=function(___, self)function self.delay(func, delay, ...)___.v.type(func, "function", 1, false)___.v.type(delay, "number", 2, false)return tempTimer(delay, function(...)func(...)end)end function self.wrap(func, wrapper)___.v.type(func, "function", 1, false)___.v.type(wrapper, "function", 2, false)return function(...)return wrapper(func, ...)end end function self.repeater(func, interval, times, ...)___.v.type(func, "function", 1, false)___.v.type(interval, "number", 2, true)___.v.type(times, "number", 3, true)interval=interval or 1 times=times or 1 local count=0 local function _repeat(...)if count<times then func(...)count=count+1 tempTimer(interval, _repeat, ...)end end _repeat(...)end end })local HttpClass=Glu.glass.register({ name="http", class_name="HttpClass", dependencies={ "table" }, setup=function(___, self)local function validate_options(options)___.v.type(options, "table", 1, false)___.v.not_empty(options, 1, false)___.v.type(options.method, "string", 2, false)___.v.regex(options.url, ___.regex.http_url, "url", 1, false)___.v.type(options.callback, "function", 1, false)end self.http_types={ "GET", "PUT", "POST", "DELETE" } local requests={} function self.download(options, cb)options.method=options.method or "GET" ___.v.type(options.saveTo, "string", 1, false)return self.request(options, cb)end function self.get(options, cb)options.method="GET" return self.request(options, cb)end function self.post(options, cb)options.method="POST" return self.request(options, cb)end function self.put(options, cb)options.method="PUT" return self.request(options, cb)end function self.delete(options, cb)options.method="DELETE" return self.request(options, cb)end function self.request(options, cb)___.v.type(options, "table", 1, false)___.v.not_empty(options, 1, false)options.callback=options.callback or cb validate_options(options)options.method=string.upper(options.method)local gl=___.getGlass("http_request")local request=gl(options, self).execute()table.insert(requests, request)return request end function self.delete_request(id)for i=1, #requests do if requests[i].id==id then table.remove(requests, i)break end end end function self.find_request(id)for _, request in ipairs(requests)do if request.id==id then return request end end return nil end end })local HttpRequestClass=Glu.glass.register({ name="http_request", class_name="HttpRequestClass", dependencies={ "table", }, setup=function(___, self, options)self.options=options function self.execute()local owner=self.container self.id=___.id()if not self.options.headers then self.options.headers={} end if type(self.options.headers)~="table" then error("headers must be a table")end self.headers=self.options.headers local function done(response_data)local ob_id=response_data.id local ob=owner.find_request(ob_id)local result={} if self.options.saveTo and not response_data.error then result.write={ ___.fd.write_file(self.options.saveTo, response_data.data)} end local cb=self.options.callback local gl=___.getGlass("http_response")local response=gl(response_data, owner)cb(response)deleteAllNamedEventHandlers(ob_id)owner.delete_request(ob_id)ob=nil response_data=nil end local events={} local lc=table.index_of(owner.http_types, self.options.method)and string.lower(self.options.method)or "custom" local uc=string.title(___.string.capitalize(lc))for _, event in ipairs({ "Done", "Error" })do local event_mod=string.format("sys%sHttp%s", uc, event)table.insert(events, { event, event_mod })end local function only_indexed(t)local tmp={} for i=1, #t do tmp[i]=t[i] end return tmp end for _, event in ipairs(events)do local event_type, event_name=unpack(event)registerNamedEventHandler(self.id, event_name, event_name, function(e, ...)local response={ event=e, id=self.id, } local result arg=only_indexed(arg)if rex.match(e, "sys(?:\\w+)HttpError$")then result=___.table.allocate({ "error", "url", "server" }, arg)elseif rex.match(e, "sys(?:\\w+)HttpDone$")then result=___.table.allocate({ "url", "data", "server" }, arg)else error("Unknown event: " .. e)end ___.table.add(response, result)done(response)end)end self.method_lc=lc self.method_uc=uc self.custom=self.options.method=="CUSTOM" local func_name=string.format("%sHTTP", lc)local func=_G[func_name] assert(func, "HTTP method " .. func_name .. " not found")assert(type(func)=="function", "HTTP method " .. func_name .. " is not a function")local ok, err, result=pcall(self.custom and function()return func(self.options.method, self.options.url, self.options.headers)end or function()return func(self.options.url, self.options.headers)end)if not ok then error("Error calling HTTP method " .. tostring(self.custom).. " " .. tostring(func).. ": " .. tostring(err))end return self end end })local HttpResponseClass=Glu.glass.register({ name="http_response", class_name="HttpResponseClass", dependencies={ "table" }, setup=function(___, self, response)self.id=response.id self.result=response end })local NumberClass=Glu.glass.register({ name="number", class_name="NumberClass", dependencies={ "table" }, setup=function(___, self)function self.round(num, digits)___.v.type(num, "number", 1, false)___.v.type(digits, "number", 2, true)digits=digits or 0 local mult=10 ^ digits return math.floor(num*mult+0.5)/mult end function self.clamp(num, min, max)___.v.type(num, "number", 1, false)___.v.type(min, "number", 2, false)___.v.type(max, "number", 3, false)return math.max(min, math.min(num, max))end function self.lerp(a, b, t)___.v.type(a, "number", 1, false)___.v.type(b, "number", 2, false)___.v.type(t, "number", 3, false)___.v.test(t>=0 and t<=1, t, 3, false, "Interpolation factor should be between 0 and 1")return a+(b-a)*t end function self.lerp_smooth(start, end_val, t)___.v.type(start, "number", 1, false)___.v.type(end_val, "number", 2, false)___.v.type(t, "number", 3, false)___.v.test(t>=0 and t<=1, t, 3, false)t=t*t*(3-2*t)return start+(end_val-start)*t end function self.lerp_smoother(start, end_val, t)___.v.type(start, "number", 1, false)___.v.type(end_val, "number", 2, false)___.v.type(t, "number", 3, false)___.v.test(t>=0 and t<=1, t, 3, false)t=t*t*t*(t*(t*6-15)+10)return start+(end_val-start)*t end function self.lerp_ease_in(start, end_val, t)___.v.type(start, "number", 1, false)___.v.type(end_val, "number", 2, false)___.v.type(t, "number", 3, false)___.v.test(t>=0 and t<=1, t, 3, false)t=t*t return start+(end_val-start)*t end function self.lerp_ease_out(start, end_val, t)___.v.type(start, "number", 1, false)___.v.type(end_val, "number", 2, false)___.v.type(t, "number", 3, false)___.v.test(t>=0 and t<=1, t, 3, false)t=t*(2-t)return start+(end_val-start)*t end function self.map(value, in_min, in_max, out_min, out_max)___.v.type(value, "number", 1, false)___.v.type(in_min, "number", 2, false)___.v.type(in_max, "number", 3, false)___.v.type(out_min, "number", 4, false)___.v.type(out_max, "number", 5, false)return(value-in_min)*(out_max-out_min)/(in_max-in_min)+out_min end function self.positive(num)___.v.type(num, "number", 1, false)return num>0 end function self.is_approximate(a, b, percent_tolerance)___.v.type(a, "number", 1, false)___.v.type(b, "number", 2, false)___.v.type(percent_tolerance, "number", 3, true)percent_tolerance=percent_tolerance or 5 local tolerance=math.abs(a)*(percent_tolerance/100)return math.abs(a-b)<=tolerance end function self.min(...)local args=___.table.n_cast(...)___.v.n_uniform(args, "number", 1, false)local result=math.huge for _, num in ipairs(args)do result=math.min(result, num)end return result end function self.max(...)local args=___.table.n_cast(...)___.v.n_uniform(args, "number", 1, false)local result=-math.huge for _, num in ipairs(args)do result=math.max(result, num)end return result end function self.sum(...)local args=___.table.n_cast(...)___.v.n_uniform(args, "number", 1, false)return ___.table.n_reduce(args, function(acc, num)return acc+num end, 0)end function self.random_clamp(min, max)___.v.type(min, "number", 1, false)___.v.type(max, "number", 2, false)return math.random()*(max-min)+min end function self.is_between(num, min, max)___.v.type(num, "number", 1, false)___.v.type(min, "number", 2, false)___.v.type(max, "number", 3, false)return num>=min and num<=max end function self.sign(num)___.v.type(num, "number", 1, false)return num>0 and 1 or(num<0 and-1 or 0)end function self.average(...)local args=___.table.n_cast(...)local values if #args==1 and type(args[1])=="table" then values=args[1] elseif #args>1 then values=args else error("Invalid argument type: expected a table or multiple numbers")end ___.v.n_uniform(values, "number", 1, false)return self.sum(values)/#values end function self.constrain(num, precision)___.v.type(num, "number", 1, false)___.v.type(precision, "number", 2, false)return math.floor(num/precision+0.5)*precision end function self.percent_of(numerator, denominator, round_digits)___.v.type(numerator, "number", 1, false)___.v.type(denominator, "number", 2, false)___.v.type(round_digits, "number", 3, true)local result=(numerator*100)/denominator if round_digits then return self.round(result, round_digits)end return result end function self.percent(percent, total, round_digits)___.v.type(percent, "number", 1, false)___.v.type(total, "number", 2, false)___.v.type(round_digits, "number", 3, true)local result=(percent*total)/100 if round_digits then return self.round(result, round_digits)end return result end function self.normalize(num, min, max)return self.map(num, min, max, 0, 1)end function self.mean(...)local args=___.table.n_cast(...)local values if #args==1 and type(args[1])=="table" then values=args[1] elseif #args>1 then values=args else error("Invalid argument type: expected a table or multiple numbers")end ___.v.n_uniform(values, "number", 1, false)return self.sum(values)/#values end end, valid=function(___, self)return { range=function(value, min, max, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=___.v.get_last_traceback_line()assert(value>=min and value<=max, "Invalid value to argument " .. argument_index .. ". Expected " .. min .. " to " .. max .. ", " .. "got " .. value .. " in\n" .. last)end } end })local QueueClass=Glu.glass.register({ name="queue", class_name="QueueClass", dependencies={ "table" }, setup=function(___, self)self.queues={} function self.new(funcs)___.v.type(funcs, "table", 1, true)___.v.n_uniform(funcs, "function", 1, false)funcs=funcs or {} local queue=___.queue_stack(funcs, self)___.table.push(self.queues, queue)return queue end function self.get(id)___.v.type(id, "string", 1, false)for _, q in pairs(self.queues)do if q.id==id then return q end end return nil, f"Queue not found for id `{id}`." end function self.push(id, f)___.v.type(id, "string", 1, false)___.v.type(f, "function", 2, false)local q, err=self:get(id)if not q then return nil, err end return q.push(f)end function self.shift(id)___.v.type(id, "string", 1, false)local q, err=self.get(id)if not q then return nil, err end return q.shift()end end })local QueueStackClass=Glu.glass.register({ name="queue_stack", class_name="QueueStackClass", dependencies={ "table" }, setup=function(___, self, opts, container)if not opts.funcs then return end local funcs=opts.funcs or {} funcs=___.table.n_cast(funcs)___.v.n_uniform(funcs, "function", 2, false)self.stack=funcs self.id=___.id()function self.push(f)___.v.type(f, "function", 1, false)return ___.table.push(self.stack, f)end function self.shift()return ___.table.shift(self.stack)end function self.execute(...)local task=self.shift()if not task then return self, nil end local result={ task(self, ...)} local count=#self.stack return self, count>0 and count or nil, unpack(result)end end })local RegexClass=Glu.glass.register({ name="regex", class_name="RegexClass", dependencies={}, setup=function(___, self)self.http_url="^(https?:\\/\\/)((([A-Za-z0-9-]+\\.)+[A-Za-z]{2,})|localhost)(:\\d+)?(\\/[^\\s]*)?$" end, valid=function(___, self)return { regex=function(value, pattern, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=___.get_last_traceback_line()assert(rex.match(value, pattern), "Invalid value to argument " .. argument_index .. ". Expected " .. pattern .. ", got " .. value .. " in\n" .. last)end } end })local SameClass=Glu.glass.register({ name="same", class_name="SameClass", dependencies={ "table" }, setup=function(___, self)function self.value_zero(value1, value2)___.v.type(value1, "any", 1, false)___.v.type(value2, "any", 2, false)if type(value1)~=type(value2)then return false end if type(value1)=="number" then if value1 ~=value1 and value2 ~=value2 then return true elseif value1==0 and value2==0 then return true elseif value1==value2 then return true else return false end end return value1==value2 end function self.value(value1, value2)___.v.type(value1, "any", 1, false)___.v.type(value2, "any", 2, false)if type(value1)~=type(value2)then return false end if type(value1)=="number" then if value1 ~=value1 and value2 ~=value2 then return true elseif value1==0 and value2==0 then return 1/value1==1/value2 elseif value1==value2 then return true else return false end end return value1==value2 end end })local StringClass=Glu.glass.register({ name="string", class_name="StringClass", dependencies={ "table" }, setup=function(___, self)function self.capitalize(str)___.v.type(str, "string", 1, false)assert(str ~="", "Expected a non-empty string")local result=str:gsub("^%l", string.upper)return result or str end function self.trim(str)___.v.type(str, "string", 1, false)return str:match("^%s*(.-)%s*$")end function self.ltrim(str)___.v.type(str, "string", 1, false)return str:match("^%s*(.-)$")end function self.rtrim(str)___.v.type(str, "string", 1, false)return str:match("^.-%s*$")end function self.strip_linebreaks(str)___.v.type(str, "string", 1, false)local result, found, subbed=rex.gsub(str, "[\\r\\n]", "")return result or str end function self.replace(str, pattern, replacement)___.v.type(str, "string", 1, false)___.v.type(pattern, "string", 2, false)___.v.type(replacement, "string", 3, false)while string.find(str, pattern)do str=string.gsub(str, pattern, replacement)or str end return str end function self.split(str, delimiter)___.v.type(str, "string", 1, false)___.v.type(delimiter, "string", 2, true)local t={} delimiter=delimiter or "." for part in str:gmatch("[^" .. delimiter .. "]+")do table.insert(t, part)end return t end function self.walk(input, delimiter)___.v.type(input, "string", 1, false)___.v.type(delimiter, "string", 2, true)local data if type(input)=="string" then data=self.split(input, delimiter)else data=input end return ___.table.walk(data)end function self.format_number(number, thousands, decimal)___.v.type(number, { "number|string" }, 1, false)___.v.type(thousands, "string", 2, true)___.v.type(decimal, "string", 3, true)thousands=thousands or "," decimal=decimal or "." number=tonumber(number)or 0 local is_negative=not ___.number.positive(number)number=math.abs(number)local numStr=tostring(number)local intPart, decPart=numStr:match("([^%.]*)%.?(.*)")local formatted="" local length=#intPart for i=1, length do if i>1 and(length-i+1)% 3==0 then formatted=thousands .. formatted end formatted=intPart:sub(length-i+1, length-i+1).. formatted end if decPart and decPart ~="" then formatted=formatted .. decimal .. decPart end if is_negative then formatted="-" .. formatted end return formatted end function self.parse_formatted_number(str, thousands, decimal)___.v.type(str, "string", 1, false)___.v.type(thousands, "string", 2, true)___.v.type(decimal, "string", 3, true)thousands=thousands or "," decimal=decimal or "." str=str:gsub(thousands, "")or str if decimal ~="." then str=str:gsub(decimal, ".")or str end return tonumber(str)or 0 end function self.starts_with(str, start)___.v.type(str, "string", 1, false)___.v.type(start, "string", 2, false)start=string.sub(start, 1)=="^" and start or "^" .. start return rex.match(str, start)~=nil end function self.ends_with(str, ending)___.v.type(str, "string", 1, false)___.v.type(ending, "string", 2, false)ending=string.sub(ending, 1)=="$" and ending or ending .. "$" return rex.match(str, ending)~=nil end function self.contains(str, pattern)___.v.type(str, "string", 1, false)___.v.type(pattern, "string", 2, false)___.v.test(not self.starts_with(pattern, "^"), "Expected pattern to not start with ^", 2)___.v.test(not self.ends_with(pattern, "$"), "Expected pattern to not end with $", 2)return rex.match(str, pattern)~=nil end function self.append(str, suffix)___.v.type(str, "string", 1, false)___.v.type(suffix, "string", 2, false)return self.ends_with(str, suffix)and str or str .. suffix end function self.prepend(str, prefix)___.v.type(str, "string", 1, false)___.v.type(prefix, "string", 2, false)return self.starts_with(str, prefix)and str or prefix .. str end function self.reg_assoc(text, patterns, tokens, default_token)default_token=default_token or-1 local work=text local results={} local token_list={} while #work>0 do local nearest_from, nearest_match, nearest_token=nil, nil, nil for i, pattern in ipairs(patterns)do local from, to=rex.find(work, pattern)if from and to then if not nearest_from or from<nearest_from then nearest_from, nearest_match, nearest_token=from, work:sub(from, to), tokens[i] or default_token end end end local prematch="" local token=nearest_token or default_token local match=nearest_match or work nearest_from=nearest_from or #work prematch=work:sub(1, nearest_from-1 or nil)print("Prematch=`" .. tostring(prematch).. "` with token `" .. tostring(token).. "` and match `" .. tostring(match).. "`")work=work:sub(nearest_from+#match)or "" table.insert(results, pre_match)table.insert(token_list, default_token)if #match>0 then table.insert(results, match)table.insert(token_list, token)end end return results, token_list end end })local TableClass=Glu.glass.register({ name="table", class_name="TableClass", dependencies={}, setup=function(___, self)function self.n_cast(...)if type(...)=="table" and self.indexed(...)then return ... end return { ... } end self.assure_indexed=self.n_cast function self.map(t, fn, ...)___.v.type(t, "table", 1, false)___.v.type(fn, "function", 2, false)local result={} for k, v in pairs(t)do result[k]=fn(k, v, ...)end return result end function self.values(t)___.v.type(t, "table", 1, false)local result={} for _, v in pairs(t)do result[#result+1]=v end return result end function self.n_uniform(t, typ)___.v.type(t, "table", 1, false)___.v.not_empty(t, 1, false)___.v.indexed(t, 1, false)___.v.type(typ, "string", 2, true)typ=typ or type(t[1])for _, v in pairs(t)do if type(v)~=typ then return false end end return true end function self.n_distinct(t)___.v.indexed(t, 1, false)local result, seen={}, {} for _, v in ipairs(t)do if not seen[v] then seen[v]=true result[#result+1]=v end end return result end function self.pop(t)___.v.type(t, "table", 1, false)___.v.indexed(t, 1, false)return table.remove(t, #t)end function self.push(t, v)___.v.type(t, "table", 1, false)___.v.type(v, "any", 2, false)___.v.indexed(t, 1, false)table.insert(t, v)return #t end function self.unshift(t, v)___.v.type(t, "table", 1, false)___.v.type(v, "any", 2, false)___.v.indexed(t, 1, false)table.insert(t, 1, v)return #t end function self.shift(t)___.v.type(t, "table", 1, false)___.v.indexed(t, 1, false)return table.remove(t, 1)end function self.allocate(source, spec)local spec_type=type(spec)___.v.type(source, "table", 1, false)___.v.not_empty(source, 1, false)___.v.indexed(source, 1, false)if spec_type==___.TYPE.TABLE then ___.v.indexed(spec, 2, false)assert(#source==#spec, "Expected source and spec to have the same number of elements")elseif spec_type==___.TYPE.FUNCTION then ___.v.type(spec, "function", 2, false)end local result={} if spec_type==___.TYPE.TABLE then for i=1, #spec do result[source[i]]=spec[i] end elseif spec_type==___.TYPE.FUNCTION then for i=1, #source do result[source[i]]=spec(i, source[i])end else for i=1, #source do result[source[i]]=spec end end return result end function self.indexed(t)___.v.type(t, "table", 1, false)local index=1 for k in pairs(t)do if k ~=index then return false end index=index+1 end return true end function self.associative(t)___.v.type(t, "table", 1, false)for k, _ in pairs(t)do if type(k)~="number" or k % 1 ~=0 or k<=0 then return true end end return false end function self.reduce(t, fn, initial)___.v.indexed(t, 1, false)___.v.type(fn, "function", 2, false)___.v.type(initial, "any", 3, false)local acc=initial for k, v in pairs(t)do acc=fn(acc, v, k)end return acc end function self.slice(t, start, stop)___.v.indexed(t, 1, false)___.v.type(start, "number", 2, false)___.v.type(stop, "number", 3, true)___.v.test(start>=1, 2, false)___.v.test(table.size(t)>=start, 2, false)___.v.test(stop and stop>=start, 3, true)if not stop then stop=#t end local result={} for i=start, stop do result[#result+1]=t[i] end return result end function self.remove(t, start, stop)___.v.indexed(t, 1, false)___.v.type(start, "number", 2, false)___.v.type(stop, "number", 3, true)___.v.test(start>=1, 2, false)___.v.test(table.size(t)>=start, 2, false)___.v.test(stop and stop>=start, 3, true)local snipped={} if not stop then stop=start end local count=stop-start+1 for i=1, count do table.insert(snipped, table.remove(t, start))end return t, snipped end function self.chunk(t, size)___.v.indexed(t, 1, false)___.v.type(size, "number", 2, false)local result={} for i=1, #t, size do result[#result+1]=___.slice(t, i, i+size-1)end return result end function self.concat(tbl, ...)___.v.indexed(tbl, 1, false)local args={ ... } for _, tbl_value in ipairs(args)do if type(tbl_value)=="table" then for _, value in ipairs(tbl_value)do table.insert(tbl, value)end else table.insert(tbl, tbl_value)end end return tbl end function self.drop(tbl, n)___.v.indexed(tbl, 1, false)___.v.type(n, "number", 2, false)___.v.test(n>=1, 2, false)return self.slice(___, tbl, n+1)end function self.drop_right(tbl, n)___.v.indexed(tbl, 1, false)___.v.type(n, "number", 2, false)___.v.test(n>=1, 2, false)return self.slice(___, tbl, 1, #tbl-n)end function self.fill(tbl, value, start, stop)___.v.indexed(tbl, 1, false)___.v.type(value, "any", 2, false)___.v.type(start, "number", 3, true)___.v.type(stop, "number", 4, true)___.v.test(start and start>=1, value, 3, true)___.v.test(stop and stop>=start, value, 4, true)for i=start or 1, stop or #tbl do tbl[i]=value end return tbl end function self.find(tbl, fn)___.v.indexed(tbl, 1, false)___.v.type(fn, "function", 2, false)for i=1, #tbl do if fn(i, tbl[i])then return i end end return nil end function self.find_last(tbl, fn)___.v.indexed(tbl, 1, false)___.v.type(fn, "function", 2, false)for i=#tbl, 1,-1 do if fn(i, tbl[i])then return i end end return nil end function self.flatten(tbl)___.v.indexed(tbl, 1, false)local result={} for _, v in ipairs(tbl)do if type(v)=="table" then ___.concat(result, v)else table.insert(result, v)end end return result end function self.flatten_deeply(tbl)___.v.indexed(tbl, 1, false)local result={} for _, v in ipairs(tbl)do if type(v)=="table" then self.concat(result, self.flatten_deeply(v))else table.insert(result, v)end end return result end function self.initial(tbl)___.v.indexed(tbl, 1, false)return self.slice(___, tbl, 1, #tbl-1)end function self.pull(tbl, ...)___.v.indexed(tbl, 1, false)local args={ ... } if #args==0 then return tbl end local removeSet={} for _, value in ipairs(args)do removeSet[value]=true end for i=#tbl, 1,-1 do if removeSet[tbl[i]] then table.remove(tbl, i)end end return tbl end function self.reverse(tbl)___.v.indexed(tbl, 1, false)local len, midpoint=#tbl, math.floor(#tbl/2)for i=1, midpoint do tbl[i], tbl[len-i+1]=tbl[len-i+1], tbl[i] end return tbl end function self.uniq(tbl)___.v.indexed(tbl, 1, false)local seen={} local writeIndex=1 for readIndex=1, #tbl do local value=tbl[readIndex] if not seen[value] then seen[value]=true tbl[writeIndex]=value writeIndex=writeIndex+1 end end for i=#tbl, writeIndex,-1 do tbl[i]=nil end return tbl end function self.unzip(tbl)___.v.indexed(tbl, 1, false)local size_of_table=#tbl local size_of_elements=#tbl[1] for _, t in ipairs(tbl)do ___.v.test(size_of_elements==#t, t, 1, false)end local num_new_sub_tables=size_of_elements local new_sub_table_size=size_of_table local result={} for i=1, num_new_sub_tables do result[i]={} end for _, source_table in ipairs(tbl)do for i, value in ipairs(source_table)do table.insert(result[i], value)end end return result end function self.new_weak(opt)___.v.test(rex.match(opt, "^(k?v?|v?k?)$"), opt, 1, true)opt=opt or "v" return setmetatable({}, { __mode=opt })end function self.weak(tbl)___.v.type(tbl, "table", 1, false)return getmetatable(tbl)and getmetatable(tbl).__mode ~=nil end function self.zip(...)local tbls={ ... } local results={} local size=#tbls[1] for _, t in ipairs(tbls)do ___.v.test(size==#t, t, 1, false)end for i=1, size do results[i]={} for _, t in ipairs(tbls)do table.insert(results[i], t[i])end end return results end function self.includes(tbl, value)___.v.indexed(tbl, 1, false)___.v.type(value, "any", 2, false)return table.index_of(tbl, value)~=nil end local function collect_tables(tbl, inherited)___.v.object(tbl, 1, false)___.v.type(inherited, "boolean", 2, true)local visited={} local tables={} local function add_table(t)if not visited[t] then table.insert(tables, t)visited[t]=true end end add_table(tbl)if inherited then local mt=getmetatable(tbl)while mt and mt.__index do local inheritedTbl=mt.__index if type(inheritedTbl)=="table" then add_table(inheritedTbl)end mt=getmetatable(inheritedTbl)end end return tables end local function get_types(tbl, test)___.v.type(tbl, "table", 1, false)___.v.type(test, "function", 2, false)local keys=table.keys(tbl)keys=table.n_filter(keys, function(k)return test(tbl, k)end)or {} return keys end local function assemble_results(tables, test)local result={} for _, t in ipairs(tables)do local keys=get_types(t, test)or {} for _, k in ipairs(keys)do if not ___.table.includes(result, k)then table.insert(result, k)end end end return result end function self.functions(tbl, inherited)___.v.object(tbl, 1, false)___.v.type(inherited, "boolean", 2, true)local tables=collect_tables(tbl, inherited)or {} local test=function(t, k)return type(t[k])=="function" end return assemble_results(tables, test)end self.methods=self.functions function self.properties(tbl, inherited)___.v.object(tbl, 1, false)___.v.type(inherited, "boolean", 2, true)local tables=collect_tables(tbl, inherited)or {} local test=function(t, k)return type(t[k])~="function" end return assemble_results(tables, test)end function self.object(tbl)___.v.type(tbl, "table", 1, false)return tbl.object==true end function self.add(tbl, value)___.v.associative(tbl, 1, false)___.v.associative(value, 2, false)for k, v in pairs(value)do tbl[k]=v end return tbl end function self.n_add(tbl1, tbl2, index)___.v.indexed(tbl1, 1, false)___.v.indexed(tbl2, 2, false)___.v.range(index, 1, #tbl1+1, 3, true)index=index or #tbl1+1 for i=1, #tbl2 do table.insert(tbl1, index+i-1, tbl2[i])end return tbl1 end function self.walk(tbl)___.v.indexed(tbl, 1, false)local i=0 return function()i=i+1 if tbl[i] then return i, tbl[i] end end end function self.element_of(list)___.v.type(list, "table", 1, false)local max=#list return list[math.random(max)] end function self.element_of_weighted(list)___.v.type(list, "table", 1, false)local total=0 for _, value in pairs(list)do total=total+value end local random=math.random(total)for key, value in pairs(list)do random=random-value if random<=0 then return key end end end local assure_equality_function=function(condition)if type(condition)~="function" then condition=function(_, k)return k==condition end end return condition end function self.all(tbl, condition)___.v.indexed(tbl, 1, false)___.v.type(condition, "any", 2, false)local count=0 condition=assure_equality_function(condition)local result=table.n_filter(tbl, condition)if result then count=#result end return count==#tbl end function self.some(tbl, condition)___.v.indexed(tbl, 1, false)___.v.type(condition, "any", 2, false)condition=assure_equality_function(condition)return table.n_filter(tbl, condition)~=nil end function self.none(tbl, condition)___.v.indexed(tbl, 1, false)___.v.type(condition, "any", 2, false)condition=assure_equality_function(condition)return table.n_filter(tbl, condition)==nil end function self.one(tbl, condition)___.v.indexed(tbl, 1, false)___.v.type(condition, "any", 2, false)condition=assure_equality_function(condition)return table.n_filter(tbl, condition)~=nil and #table.n_filter(tbl, condition)==1 end function self.count(tbl, condition)___.v.indexed(tbl, 1, false)___.v.type(condition, "any", 2, false)condition=assure_equality_function(condition)return #table.n_filter(tbl, condition)end end, valid=function(___, self)return { not_empty=function(value, argument_index, nil_allowed)assert(type(value)=="table", "Invalid type to argument " .. argument_index .. ". Expected table, got " .. type(value).. " in\n" .. ___.get_last_traceback_line())if nil_allowed and value==nil then return end local last=___.get_last_traceback_line()assert(not table.is_empty(value), "Invalid value to argument " .. argument_index .. ". Expected non-empty in\n" .. last)end, n_uniform=function(value, expected_type, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=___.get_last_traceback_line()assert(self.n_uniform(value, expected_type), "Invalid type to argument " .. argument_index .. ". Expected an " .. "indexed table of " .. expected_type .. " in\n" .. last)end, indexed=function(value, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=___.get_last_traceback_line()assert(self.indexed(value), "Invalid value to argument " .. argument_index .. ". Expected indexed table, got " .. type(value).. " in\n" .. last)end, associative=function(value, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=___.get_last_traceback_line()assert(self.associative(value), "Invalid value to argument " .. argument_index .. ". Expected " .. "associative table, got " .. type(value).. " in\n" .. last)end, object=function(value, argument_index, nil_allowed)if nil_allowed and value==nil then return end local last=___.get_last_traceback_line()assert(self.object(value), "Invalid value to argument " .. argument_index .. ". Expected object, got " .. type(value).. " in\n" .. last)end, option=function(value, options, argument_index)___.v.type(value, "any", argument_index, false)___.v.indexed(options, argument_index, false)___.v.type(argument_index, "number", 3, false)local last=___.get_last_traceback_line()assert(table.index_of(options, value)~=nil, "Invalid value to " .. "argument " .. argument_index .. ". Expected one of " .. table.concat(options, ", ").. ", got " .. value .. " in\n" .. last)end } end, })local TestClass=Glu.glass.register({ name="test", class_name="TestClass", call="runner", dependencies={ "table", "test_runner" }, setup=function(___, self)local testers={} function self.runner(opts)local runner=___.test_runner(opts, self)testers[runner.id]=runner return runner end local function sum(tests)local result=0 for _, test in ipairs(tests)do result=result+test end return result end local function sum_field(tbls, field)local totals={} for _, tbl in ipairs(tbls)do table.insert(totals, tbl[field])end return sum(totals)end function self.summary(runner)local good_colour, bad_colour=unpack(___.table.values(runner.colours))local total_run=sum_field(runner.tests, "total")local total_pass=sum_field(runner.tests, "passes")local total_fail=sum_field(runner.tests, "fails")print("")cecho("<b>Tests run:</b><gold>" .. total_run .. "<r>\n")cecho("<b>Successes:</b>" .. good_colour .. total_pass .. "<r>\n")cecho("<b>Failures:</b>" .. bad_colour .. total_fail .. "<r>\n")end return self end })local TestRunnerClass=Glu.glass.register({ name="test_runner", class_name="TestRunnerClass", call="new_runner", dependencies={ "table" }, setup=function(___, self)function self.new_runner(opts, owner)self.id=___.id()self.tests={} self.colours={ pass=(opts.colour and opts.colour.pass)or "<yellow_green>", fail=(opts.colour and opts.colour.fail)or "<orange_red>", } self.symbols={ pass=(opts.symbol and opts.symbol.pass)or utf8.escape("%x{2714}"), fail=(opts.symbol and opts.symbol.fail)or utf8.escape("%x{2718}"), } ___.v.colour_name(self.colours.pass, 2, false)___.v.colour_name(self.colours.fail, 2, false)local cond=___.conditions local default={ tests={} } local resets={ passes=0, fails=0, total=0 } function self.add(name, test)table.insert(self.tests, { name=name, test=test, passes=0, fails=0, total=0, runner=self, })return self end function self.remove(name)for i, test in ipairs(self.tests)do if test.name==name then table.remove(self.tests, i)return self end end error(f "Test '{name}' not found")end if opts.tests then repeat local name, test=unpack(___.table.values(table.remove(opts.tests, 1)))self.add(name, test)until table.size(opts.tests)==0 end function self.print()for _, test in ipairs(self.tests)do cecho(f "<b>{test.name}<r>\n")end return self end function self.reset()for k, v in pairs(resets)do for _, test in ipairs(self.tests)do test[k]=v end end return self end function self.wipe()for _, v in pairs(self.tests)do v=nil end return self end function self.pass(test)test.total=test.total+1 test.passes=test.passes+1 end function self.fail(test)test.total=test.total+1 test.fails=test.fails+1 end function self.execute(reset_when_done)reset_when_done=reset_when_done or false self.reset()for _, t in ipairs(self.tests)do local status_message=f "<light_goldenrod>Running test '{t.name}' " .. "(<r><seashell>%d<r><light_goldenrod>): " local success, result, fail_message=(function(test, condition)registerNamedEventHandler(test.name, test.name, "condition_is", function(_, c)if c==true then self.pass(test)elseif c==false then self.fail(test)else error(f "Expected a boolean, got {c}")end end)local success, result, fail_message=pcall(test.test, condition, self, test)deleteNamedEventHandler(test.name, test.name)return success, result, fail_message end)(t, cond)if not success or not result then self.fail(t)status_message=status_message .. self.colours.fail .. self.symbols.fail .. "\n" .. " " .. self.colours.fail .. "Error in test '" .. t.name .. "':\n" .. " " .. tostring(result or fail_message).. "\n" else self.pass(t)status_message=status_message .. self.colours.pass .. self.symbols.pass .. "\n" end status_message=string.format(status_message, t.total)cecho(status_message)end owner.summary(self)if reset_when_done then self.reset()end return self end return self end end })local TimerClass=Glu.glass.register({ name="timer", class_name="TimerClass", dependencies={ "table" }, setup=function(___, self)self.multi_timers={} local function perform_multi_timer_function(name)local timer_function=mod.multi_timers[name] if not timer_function then return false end local defs=timer_function.def local def=defs[1] local ok, result=pcall(def.func, def.args)if not ok then return false end table.remove(defs, 1)if #defs>0 then local result2=___.timer.multi(name, defs)if not result2 then return false end else ___.timer.kill_multi(name)end return true end function self.multi(name, def, delay)___.v.type(name, "string", 1, false)___.v.not_empty(def, 2, false)___.v.type(delay, "number", 3, true)if delay then def=___.table.map(def, function(_, element)element.delay=delay return element end)end self.multi_timers[name]={ def=def } local timer_result local timer_id=tempTimer(def[1].delay, function()timer_result=perform_multi_timer_function(name)end)if not timer_id then ___.timer.kill_multi(name)return false end self.multi_timers[name].id=timer_id return true end function self.kill_multi(name)___.v.type(name, "string", 1, false)local timer_function=self.multi_timers[name] if not timer_function then return nil end self.multi_timers[name]=nil local id=timer_function.id if id then return killTimer(id)end return true end end })local TryClass=Glu.glass.register({ class_name="TryClass", name="try", inherit_from=nil, call="clone", setup=function(___, self, opts)local result={ try=nil, catch=nil, finally=nil, result=nil } function self.clone(f, ...)local glass=___.getGlass("try")assert(glass, "TryClass not found")local try=glass(opts, self)return try.try(f, ...)end function self.try(f, ...)local success, try_result, b=pcall(f, ...)if success and try_result then result.try={ success=success, error=nil, result=try_result } result.result=try_result else self.caught=true result.try={ success=success, error=try_result, result=nil } end return self end function self.catch(f)local success, catch_result=pcall(f, result.try)if success then catch_result.catch={ success=true, error=nil } end return self end function self.finally(f)local success, finally_result=pcall(f, result)if not success then error("Error in finally block: " .. finally_result)end return self end end })local UrlClass=Glu.glass.register({ name="url", class_name="UrlClass", dependencies={ "table" }, setup=function(___, self)function self.decode(str)___.v.type(str, "string", 1, false)str=(string.gsub(str, '+', ' ')or str)str=(string.gsub(str, '%%(%x%x)', function(h)return string.char(tonumber(h, 16))end)or str)return str end function self.encode(str)___.v.type(str, "string", 1, false)str=(string.gsub(str, "([^%w])", function(c)return string.format("%%%02X", string.byte(c))end)or str)return str end function self.decode_params(query_string)local params={} for key_value in rex.gmatch(query_string, "([^&]+)")do local key, value=rex.match(key_value, "([^=]+)=([^=]+)")if key and value then params[self.decode(key)]=self.decode(value)end end return params end function self.encode_params(params)local encoded={} for key, value in pairs(params)do table.insert(encoded, self.encode(key).. "=" .. self.encode(value))end return table.concat(encoded, "&")or "" end function self.parse(url)___.v.type(url, "string", 1, false)local protocol, host, port, path, query_string=rex.match(url, "^(https?)://([^/:]+)(?::(\\d+))?/([^?]*)\\??(.*)")local file=(rex.match(path, "([^/]+)$")or path)local params=self.decode_params(query_string or "")protocol=protocol and protocol or "http" port=port and tonumber(port)or protocol and(protocol=="http" and 80 or 443)local parsed={ protocol=protocol, host=host, port=port, path=path, file=file, params=params } return parsed end end })local VersionClass=Glu.glass.register({ name="version", class_name="VersionClass", dependencies={ "table" }, setup=function(___, self)local function _compare(one, two)if one==two then return 0 end if type(one)=="number" then return one<two and-1 or 1 elseif type(one)=="string" then return one<two and-1 or 1 end return one<two and-1 or 1 end function self.compare(version1, version2)___.v.test(type(version1)=="string" or type(version1)=="number", 1, "Invalid value to argument 1. Expected a string or number.")___.v.test(type(version2)=="string" or type(version2)=="number", 2, "Invalid value to argument 2. Expected a string or number.")___.v.same_type(version1, version2)version1=tostring(version1)version2=tostring(version2)local version1_parts=version1:split("%.")or {} local version2_parts=version2:split("%.")or {} ___.v.test(type(version1_parts)=="table", 1, "Invalid value to argument 1. Expected a string.")___.v.test(type(version2_parts)=="table", 2, "Invalid value to argument 2. Expected a string.")___.v.test(#version1_parts==#version2_parts, 1, "Invalid value to arguments. Expected 1 and 2 to have the same number of parts.")for i=1, #version1_parts do local result=_compare(version1_parts[i], version2_parts[i])if result ~=0 then return result end end return 0 end end })
-- Generated by MudletBuilder


-- File: glu.lua
-- Glu cannot use Glass because the constructors will be different. The
-- factory is for modules and any other classes in Glu.

if not _G["Glu"] then
  Glu = {}
  Glu.__index = Glu
  table.unpack = table.unpack or unpack

  local registeredGlasses = {}

  function Glu.get_glasses() return registeredGlasses end
  function Glu.get_glass_names()
    local names = {}
    local glasses = Glu.get_glasses()
    for _, glass in ipairs(glasses or {}) do
      table.insert(names, glass.name)
    end
    return names
  end
  function Glu.get_glass(name)
    for _, glass in ipairs(Glu.get_glasses()) do
      if glass.name == name then
        return glass
      end
    end
    return nil
  end
  function Glu.has_glass(name)
    return Glu.get_glass(name) ~= nil
  end

  function Glu.id()
    local function random_hex(length)
      return string.format("%0" .. length .. "x", math.random(0, 16 ^ length - 1))
    end

    local result = string.format("%s%s-%s-4%s-%x%s-%s%s%s",
      random_hex(4),
      random_hex(4),
      random_hex(4),
      random_hex(3),
      8 + math.random(0, 3),
      random_hex(3),
      random_hex(4),
      random_hex(4),
      random_hex(4)
    )

    ---@diagnostic disable-next-line: return-type-mismatch
    return result
  end

  -- Make Glu callable
  setmetatable(Glu, { __call = function(_, ...) return Glu.new(...) end })

  local function new_object(glu_instance, glass, instance_opts, container)
    instance_opts = instance_opts or {}
    container = container or glu_instance

    -- Check for circular dependencies
    local function check_index_for_loop(ob)
      local seen = {}
      local current = ob

      while current do
        if seen[current] then
          error(">>   [newObject] Loop detected in __index chain for: " .. ob.name)
        end
        seen[current] = true
        current = getmetatable(current) and getmetatable(current).__index
      end
      return false
    end

    local function copy_properties(glu_class, into)
      local object = into[glu_class.name]
      for k, v in pairs(object) do
        glu_instance[glu_class.name][k] = v
      end

      -- Copy metatable info
      local meta = getmetatable(object)
      if meta then
        setmetatable(glu_instance[glu_class.name], meta)
      end
    end

    local function instantiate(glu, glu_class, ops, into)
      if check_index_for_loop(glu_class) then return end
      -- If the class has a parent, make sure it is instantiated first
      if glu_class.inherit_from then
        local parent_name = glu_class.inherit_from
        local parent = into.get_object(parent_name)

        if not parent or (parent.glass and parent.glass.setup) then
          local parent_class = glu.get_glass(parent_name)
          -- Recursively instantiate the parent class
          return instantiate(glu, parent_class, ops, into)
          -- error("Parent class `" .. glu_class.inherit_from .. "` not found for `" .. glu_class.name .. "`")
        end
      end

      -- Instantiate the current class if it hasn't been already
      if not glu[glu_class.name] or table.index_of(table.keys(glu[glu_class.name]), "name") == nil then
        local object = glu_class(ops, glu)
        into[glu_class.name] = object   -- Add the instance to `instance`
        copy_properties(glu_class, into)
        return object
      end
    end

    return instantiate(glu_instance, glass, instance_opts, container)
  end

  function Glu.new(pkg, module_dir_name)
    assert(type(pkg) == "string", "Package name must be a string.")
    assert(type(module_dir_name) == "string" or module_dir_name == nil, "Module directory name must be a string or nil.")

    local instance = {
      name = "Glu",
      package_name = pkg,
      module_dir_name = module_dir_name,
      objects = {},
      container = nil,
      TYPE = {
        BOOLEAN = "boolean",
        ["boolean"] = "boolean",
        FUNCTION = "function",
        ["function"] = "function",
        NIL = "nil",
        ["nil"] = "nil",
        NUMBER = "number",
        ["number"] = "number",
        STRING = "string",
        ["string"] = "string",
        TABLE = "table",
        ["table"] = "table",
        THREAD = "thread",
        ["thread"] = "thread",
        USERDATA = "userdata",
        ["userdata"] = "userdata",
      },
      ENUM_ELEMENT_TYPE = { INDEXED = 1, MIXED = 2 }
    }

    -- Add the Glass class to the instance
    instance.glass = Glu.glass

    setmetatable(instance, Glu)

    -- If the glu_modules table is empty, it means that we weren't loaded
    -- from a package with Mudlet. So, we have to detect the modules ourselves.
    if table.size(registeredGlasses) == 0 then
      -- In the event that we have added Glu in our package as resource files,
      -- we need to detect those modules and load them.
      local function detectModules(module_path, require_path)
        local filter = "glu.lua"

        for file in lfs.dir(module_path) do
          if file:match("%.lua$") and file ~= filter then
            local module_name = file:match("^(.-)%.lua$")
            local require_file = string.format("%s/%s", require_path, module_name)
            assert(type(module_name) == "string", "Module name must be a string")
            assert(type(require_file) == "string", "Module file must be a string")
            require(require_file) -- load the file. its event handler will fire
          end
        end
      end

      local pkg_path = getMudletHomeDir() .. "/" .. pkg
      local module_path = pkg_path .. "/" .. module_dir_name
      local require_path = pkg .. "/" .. module_dir_name
      assert(type(module_dir_name) == "string", "Module directory name must be a string")
      assert(lfs.attributes(pkg_path), "Package directory " .. pkg .. " does not exist")
      assert(lfs.attributes(module_path), "Module directory " .. module_dir_name .. " does not exist in package " .. pkg)
      detect_modules(module_path, require_path)
    end

    -- Either way, we should have modules by now.
    assert(table.size(registeredGlasses) > 0, "No modules found in " .. pkg)

    function instance.getPackageName() return instance.package_name end
    function instance.has_object(name) return instance.get_object(name) ~= nil end
    function instance.get_object(name) return instance[name] and type(instance[name]) == "table" and instance[name] or nil end

    -- OOB Validation functions
    -- Standard validation functions
    local trace_ignore = debug.getinfo(1).source
    function instance.get_last_traceback_line()
      local it, trace = 1, ""
      while debug.getinfo(it) do
        if debug.getinfo(it).source ~= trace_ignore then
          local line = debug.getinfo(it).source ..
              ":" ..
              debug.getinfo(it).currentline
          trace = trace .. line .. "\n"
        end
        it = it + 1
      end

      if #trace == 0 then
        return "[No traceback]"
      end

      return trace
    end

    instance.v = {
      get_last_traceback_line = instance.get_last_traceback_line,
      test = function(statement, value, argument_index, nil_allowed)
        if nil_allowed and value == nil then
          return
        end

        local last = instance.get_last_traceback_line()
        assert(statement, "Invalid value to argument " .. argument_index ..
          ". " .. tostring(value) .. " in\n" .. last)
      end,
      type = function(value, expected_type, argument_index, nil_allowed)
        local last = instance.get_last_traceback_line()
        assert((nil_allowed == true and value == nil) or value ~= nil,
          "value must not be nil for argument " .. argument_index ..
          " in\n" .. last)
        assert(type(expected_type) == "string",
          "expected_type must be a string for argument " .. argument_index ..
          " in\n" .. last)
        assert(type(argument_index) == "number",
          "argument_index must be a number for argument " .. argument_index ..
          " in\n" .. last)
        assert(nil == nil_allowed or type(nil_allowed) == "boolean",
          "nil_allowed must be a boolean for argument " .. argument_index ..
          " in\n" .. last)

        if nil_allowed and value == nil then return end
        if expected_type == "any" then return end

        local expected_types = string.split(expected_type, "|") or { expected_type }
        local invalid = table.n_filter(expected_types, function(t) return not instance.TYPE[t] end)

        if table.size(invalid) > 0 then
          error("Invalid type to argument " ..
            argument_index .. ". Expected " .. table.concat(invalid, "|") .. ", got " .. type(value) .. " in\n" .. last)
        end

        for _, t in ipairs(expected_types) do
          if type(value) == t then return end
        end

        error("Invalid type to argument " ..
          argument_index .. ". Expected " .. expected_type .. ", got " .. type(value) .. " in\n" .. last)
      end
    }

    -- Let's now create them!
    for _, class in ipairs(registeredGlasses) do
      new_object(instance, class, {}, instance)
    end

    -- Trap events for uninstalling the package and clean ourselves up.
    local handler_name = "glu_sysUninstall_" .. Glu.id()
    instance.handler_name = handler_name
    registerNamedEventHandler("glu", handler_name, "sysUninstall",
      function(event, p)
        if p == instance.package_name then
          deleteNamedEventHandler("glu", handler_name)
          instance = nil
        end
      end
    )

    return instance
  end

  -- Glass
  Glass = {
    name = "glu_glass",
    class_name = "Glass",
    inherit_from = nil,
    dependencies = {},
    protect = function(glass, self)
      local function protect_function(object, function_name)
        assert(type(object) == "table", "`object` must be a table")
        assert(type(function_name) == "string", "`function_name` must be a string")

        local original_function = object[function_name]
        assert(type(original_function) == "function", "`original_function` must be a function")

        object[function_name] = function(caller, ...)
          if self.inherits(object) then
            return original_function(caller, ...)
          end
          error("Access denied: " .. function_name .. " is protected and can " ..
            "only be called by inheriting classes.")
        end
      end

      local function protect_variable(object, var_name)
        assert(type(object) == "table", "`object` must be a table")
        assert(type(var_name) == "string", "`var_name` must be a string")
        assert(type(object[var_name]) ~= "nil", "`object[var_name]` must not be nil")

        local base_class = getmetatable(object)

        setmetatable(object, {
          __index = function(tbl, key)
            if key == var_name and not self.inherits(tbl, base_class) then
              error("Access denied: Variable '" ..
                var_name .. "' is protected and can only be accessed by inheriting classes.")
            end
            return rawget(tbl, key)
          end,
          __newindex = function(tbl, key, value)
            if key == var_name and not self.inherits(tbl, base_class) then
              error("Access denied: Variable '" ..
                var_name .. "' is protected and can only be modified by inheriting classes.")
            end
            rawset(tbl, key, value)
          end,
        })
      end

      if glass.protected_functions then
        for _, function_name in ipairs(glass.protected_functions) do
          protect_function(self, function_name)
        end
      end

      if glass.protected_variables then
        for _, var_name in ipairs(glass.protected_variables) do
          protect_variable(self, var_name)
        end
      end
    end,
    register = function(class_opts)
      assert(type(class_opts) == "table", "opts must be a table")
      assert(type(class_opts.name) == "string", "`name` must be a string")
      assert(type(class_opts.class_name) == "string", "`class_name` must " ..
        "be a string")
      assert(type(class_opts.inherit_from) == "string" or
        class_opts.inherit_from == nil,
        "`inherit_from` must be a string or nil")
      assert(type(class_opts.setup) == "function", "`setup` must " ..
        "be a function")
      assert(type(class_opts.valid) == "function" or class_opts.valid == nil,
        "`valid` must be a function or nil")

      local name = class_opts.name

      -- Declare the class. And return it if it already exists.
      local G = Glu.get_glass(name)
      if G then return G end

      G = {
        name = name,
        class_name = class_opts.class_name,
        inherit_from = class_opts.inherit_from,
        dependencies = class_opts.dependencies or {},
        setup = class_opts.setup,
        valid = class_opts.valid,
        protected_functions = class_opts.protected_functions,
        protected_variables = class_opts.protected_variables,
      }

      function G.new(instance_opts, container)
        -- The instance_opts must be a table or nil
        assert(type(instance_opts) == "table" or instance_opts == nil, "`instance_opts` must be " ..
          "a table or nil")
        -- The container must be a table with a metatable
        assert(type(container) == "table", "`container` must be a table")

        -- Setup instance
        local self = {
          inherit_from = class_opts.inherit_from,
          name = class_opts.name,
          class = class_opts.class_name,
          call = class_opts.call,
          container = container,
          objects = {},
          object = true,
        }
        self.__index = self

        -- Determine anchor
        local ___ = self
        repeat ___ = ___.container until not ___.container
        self.___ = ___

        -- Set the __index for inheritance if there is a parent class
        if class_opts.inherit_from then
          local inherit_from = class_opts.inherit_from
          local parent_instance = ___.get_object(inherit_from)

          if not parent_instance then
            error("Instance of parent class `" .. inherit_from .. "` not " ..
              "found for `" .. class_opts.class_name .. "`")
          end

          self.parent = parent_instance

          setmetatable(self, { __index = parent_instance })
        else
          self.__index = self
        end

        for _, dep in ipairs(class_opts.dependencies or {}) do
          local obj = ___[dep]
          if not obj then
            local glass = ___.get_glass(dep)
            if not glass then
              error("Object `" .. dep .. "` not found for `" ..
                class_opts.class_name .. "`")
            else
              obj = new_object(___, glass, {}, ___.container)
            end
          end
        end

        -- If we don't have a name, use a random UUID
        local instance_name = self.name or ___.id()

        -- Validation functions
        if G.valid and type(G.valid) == "function" then
          ___.v = ___.v or {}
          local valid = G.valid(___, self)
          if valid then
            for valid_function_name, valid_function in pairs(valid) do
              ___.v[valid_function_name] = valid_function
            end
          end
        end

        -- Add the instance to the container
        container.objects[instance_name] = self
        if table.index_of(table.keys(G), "setup") and
          type(G.setup) == "function" then
          -- Initialize the instance
          G.setup(___, self, instance_opts, container)
        end

        function self.inherits(base_class)
          local current_instance = self
          while current_instance do
            if current_instance == base_class then
              return true
            end
            current_instance = current_instance.parent
          end
          return false
        end

        -- Protect the functions and variables
        ___.glass.protect(G, self)

        assert(type(self.call) == "string" or self.call == nil,
          "`call` must be a string or nil")

        if self.call then
          local mt = getmetatable(self) or {}
          mt.__call = function(_, ...)
            local args = { ... }
            return self[self.call](unpack(args))
          end
          setmetatable(self, mt)
        end

        return self
      end

      table.insert(registeredGlasses, G)

      -- Set the metatable for the class. Always use the class's own `new` method for `__call`.
      setmetatable(G, {
        __index = class_opts.inherit_from or nil,
        __call = function(_, ...) return G.new(...) end
      })

      tempTimer(0, function() raiseEvent("Glu.Glass.Registered", G) end)

      return G
    end
  }
  setmetatable(Glass, {
    __index = Glass,
    __call = function(_, ...) return Glass.new(...) end
  })
  Glu.glass = Glass
end


-- File: glass_loader.lua
local GlassLoaderClass = Glu.glass.register({
  class_name = "GlassLoaderClass",
  name = "glass_loader",
  call = "load_glass",
  dependencies = { "try" },
  setup = function(___, self, instance_opts, container)

    function self.load_glass(opts)
      local path = opts.path
      local cb = opts.cb or opts.callback
      local execute = opts.execute
      local path_type = ___.string.starts_with(path, "https?://") and "url" or "path"

      local tried = ___
        .try(function()
          local function load_glass_from_data(data)
            local f = loadstring(data)

            return f or false, "Failed to load glass from data"
          end

          local function done(result)
            if not result then
              return false, "Failed to load glass from path"
            end

            if execute then
              local load_result
              local load_try = ___
                .try(function()
                  load_result = result()
                end)
                .catch(function(catch_result)
                  return false, "Failed to execute glass: " .. catch_result.try.error
                end)
            end

            return result
          end

          if not path then return false, "No file or url provided" end

          if path_type == "url" then
            local request = ___.http.get({ url = path }, function(response)
              if response.result.error then
                return false, "Failed to load glass from url: " .. response.result.error
              end

              return done(load_glass_from_data(response.result.data))
            end)
          else
            local data, err, code = ___.fd.read_file(path)
            if not data then return false, err end

            return done(load_glass_from_data(data))
          end
        end)
      if tried.caught then
        tried.catch(function(result)
          cb(nil, "Failed to load glass from " .. path_type .. ": " .. result.try.error)
        end)
      else
        cb(tried.result.result)
      end
    end
  end
})


-- File: conditions.lua
local ConditionsClass = Glu.glass.register({
  class_name = "ConditionsClass",
  name = "conditions",
  dependencies = {},
  setup = function(___, self)
    --- Checks if a condition is true or false.
    --- @param condition boolean - The condition to check
    --- @param message string|nil - The message to return if the condition is false
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is(condition, message)
      assert(type(condition) == "boolean", "Expected a boolean as the first argument")
      assert(type(message) == "string" or message == nil, "Expected a string or nil as the second argument")

      raiseEvent("condition_is", condition)
      return condition, condition and nil or message
    end

    --- Checks if a condition is true.
    --- @param condition boolean - The condition to check
    --- @param message string|nil - The message to return if the condition is false
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_true(condition, message)
      return self.is(condition, message or "Expected condition to be true")
    end

    --- Checks if a condition is false.
    --- @param condition boolean - The condition to check
    --- @param message string|nil - The message to return if the condition is true
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_false(condition, message)
      return self.is(not condition, message or "Expected condition to be false")
    end

    --- Checks if a value is nil.
    --- @param value any - The value to check
    --- @param message string|nil - The message to return if the value is not nil
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_nil(value, message)
      return self.is(value == nil, message or "Expected `{value}` to be nil")
    end

    --- Checks if a value is not nil.
    --- @param value any - The value to check
    --- @param message string|nil - The message to return if the value is nil
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_not_nil(value, message)
      return self.is(value ~= nil, message or "Expected `{value}` to not be nil")
    end

    --- Checks if a function throws an error.
    --- @param func function - The function to check
    --- @param message string|nil - The message to return if the function does not throw an error
    --- @param check function|nil - The function to check the error message against
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_error(func, message, check)
      assert(type(func) == "function", "Expected a function as the first argument")
      assert(type(message) == "string" or message == nil, "Expected a string or nil as the second argument")
      assert(type(check) == "function" or check == nil, "Expected a function or nil as the third argument")

      local test_success, test_err = pcall(func)
      local error_success, error_err

      if not test_success then
        if(check) then
          error_success, error_err = pcall(check, test_err, self)
        else
          error_success, error_err = true, nil
        end
      end

      -- If `pcall` fails (returns false), we know the function threw an error
      return self.is(not error_success,
        message or f "Expected function to throw an error but it did not. Error: {error_err}"
      )
    end

    --- Checks if two values are equal.
    --- @param a any - The first value to check
    --- @param b any - The second value to check
    --- @param message string|nil - The message to return if the values are not equal
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_eq(a, b, message)
      return self.is(a == b,
        message or f "Expected `{a}` to equal `{b}`\n")
    end

    --- Checks if two values are not equal.
    --- @param a any - The first value to check
    --- @param b any - The second value to check
    --- @param message string|nil - The message to return if the values are equal
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_ne(a, b, message)
      return self.is(a ~= b,
        message or f "Expected `{a}` to not equal `{b}`\n")
    end

    --- Checks if a value is less than another value.
    --- @param a any - The first value to check
    --- @param b any - The second value to check
    --- @param message string|nil - The message to return if the values are not less than
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_lt(a, b, message)
      return self.is(a < b,
        message or f "Expected `{a}` to be less than `{b}`\n")
    end

    --- Checks if a value is less than or equal to another value.
    --- @param a any - The first value to check
    --- @param b any - The second value to check
    --- @param message string|nil - The message to return if the values are not less than or equal to
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_le(a, b, message)
      return self.is(a <= b,
        message or f "Expected `{a}` to be less than or equal to `{b}`\n")
    end

    --- Checks if a value is greater than another value.
    --- @param a any - The first value to check
    --- @param b any - The second value to check
    --- @param message string|nil - The message to return if the values are not greater than
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_gt(a, b, message)
      return self.is(a > b,
        message or f "Expected `{a}` to be greater than `{b}`\n")
    end

    --- Checks if a value is greater than or equal to another value.
    --- @param a any - The first value to check
    --- @param b any - The second value to check
    --- @param message string|nil - The message to return if the values are not greater than or equal to
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_ge(a, b, message)
      return self.is(a >= b, message or f "Expected `{a}` to be greater than or equal to `{b}`\n")
    end

    --- Checks if a value is of a specific type.
    --- @param value any - The value to check
    --- @param type string - The type to check against
    --- @param message string|nil - The message to return if the values are not of the specified type
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_type(value, type, message)
      return self.is(type(value) == type, message or f "Expected `{value}` to be of type `{type}`\n")
    end

    --- Checks if two values are deeply equal.
    --- @param a any - The first value to check
    --- @param b any - The second value to check
    --- @param message string|nil - The message to return if the values are not deeply equal
    --- @return boolean - The condition
    --- @return string|nil - The message
    function self.is_deeply(a, b, message)
      local result, mess

      local function deep_compare(first, second, visited)
        visited = visited or {}

        -- If both values are not tables, use is_eq for proper state tracking
        if type(first) ~= "table" or type(second) ~= "table" then
          result, mess = self.is_eq(first, second, message or f "Expected `{first}` to equal `{second}`")

          return result, result and nil or mess
        end

        -- If we've seen this pair of tables before, they're equal
        for v1, v2 in pairs(visited) do
          if v1 == first and v2 == second then
            return true
          end
        end

        -- Mark these tables as being compared
        visited[first] = second

        -- Compare all keys and values
        for k, v in pairs(first) do
          if second[k] == nil then
            return false, f "Key `{k}` missing in second table"
          end

          local equal, err = deep_compare(v, second[k], visited)
          if not equal then
            return false, err
          end
        end

        -- Check for extra keys in second
        for k in pairs(second) do
          if first[k] == nil then
            return false, f "Extra key `{k}` in second table"
          end
        end

        return true
      end

      return deep_compare(a, b, {})
    end
  end
})


-- File: colour.lua
local ColourClass = Glu.glass.register({
  class_name = "ColourClass",
  name = "colour",
  dependencies = { "number",},
  setup = function(___, self)
    local v = self.v
    --- Interpolates between two RGB colours based on a step value. Functionally,
    --- it takes two colours and returns a third colour somewhere between the
    --- two colours, based on the step value. Generally used to fade between two
    --- colours. The step value is the current transition percentage as a whole
    --- number between the two colours, with 0 being the first colour and 100 being
    --- the second colour.
    ---
    --- Available interpolation methods are:
    --- - linear
    --- - smooth (default)
    --- - smoother
    --- - ease_in
    --- - ease_out
    ---
    --- @example
    --- ```lua
    --- colour.interpolate({255, 0, 0}, {0, 0, 255}, 50)
    --- -- {127, 0, 127}
    --- ```
    --- @param rgb1 table - The first RGB colour as a table with three elements: red, green, and blue.
    --- @param rgb2 table - The second RGB colour as a table with three elements: red, green, and blue.
    --- @param factor number - The step value between 0 and 1.
    --- @param method string - The interpolation method to use. (Optional, defaults to "smooth")
    --- @return table - The interpolated RGB colour as a table with three elements: red, green, and blue.
    function self.interpolate(rgb1, rgb2, factor, method)
      ___.v.rgb_table(rgb1, 1, false)
      ___.v.rgb_table(rgb2, 2, false)
      ___.v.type(factor, "number", 3, false)
      ___.v.range(factor, 0, 100, 3, false)

      -- Available interpolation methods
      local lerps = {
        linear = ___.number.lerp,
        smooth = ___.number.lerp_smooth,
        smoother = ___.number.lerp_smoother,
        ease_in = ___.number.lerp_ease_in,
        ease_out = ___.number.lerp_ease_out
      }

      -- Default to smooth as it often looks better for colors
      method = method or 'smooth'

      -- Validate method if provided
      local valid_methods = table.keys(lerps)
      local lerp_func = lerps[method]
      ___.v.test(lerp_func ~= nil,
        f"Invalid interpolation method: {method}. Must be one of: " ..
          table.concat(valid_methods, ", "), 4, false)

      local hsl1 = self.rgb_to_hsl(rgb1)
      local hsl2 = self.rgb_to_hsl(rgb2)
      local t = factor / 100

      -- Special handling for hue to ensure we take shortest path around the color wheel
      local h1, h2 = hsl1[1], hsl2[1]
      local diff = h2 - h1
      if diff > 180 then h2 = h2 - 360
      elseif diff < -180 then h2 = h2 + 360 end

      local h = lerp_func(h1, h2, t) % 360
      local s = lerp_func(hsl1[2], hsl2[2], t)
      local l = lerp_func(hsl1[3], hsl2[3], t)

      return self.hsl_to_rgb({h, s, l})
    end

    function self.rgb_to_hsl(rgb)
      ___.v.rgb_table(rgb, 1, false)

      local r, g, b = rgb[1] / 255, rgb[2] / 255, rgb[3] / 255
      local max, min = math.max(r, g, b), math.min(r, g, b)
      local h, s, l = 0, 0, (max + min) / 2

      if max ~= min then
        local d = max - min
        s = l > 0.5 and d / (2 - max - min) or d / (max + min)

        if max == r then
          h = (g - b) / d + (g < b and 6 or 0)
        elseif max == g then
          h = (b - r) / d + 2
        else
          h = (r - g) / d + 4
        end

        h = h / 6
      end

      -- Convert to degrees/percentages and ensure numbers
      return {
        math.floor(h * 360 + 0.5),
        math.floor(s * 100 + 0.5),
        math.floor(l * 100 + 0.5)
      }
    end

    --- Converts an RGB colour to a hex string.
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @param include_background boolean - Whether to include a background colour. (Optional, defaults to false)
    --- @return string - The hex string.
    ---
    --- @example
    --- ```lua
    --- colour.to_hex({255, 255, 255})
    --- -- "#ffffff"
    --- ```
    function self.to_hex(rgb, include_background)
      ___.v.rgb_table(rgb, 1, false)
      ___.v.type(include_background, "boolean", 2, true)

      -- Convert RGB to hex format
      local function to_hex_part(r, g, b)
        return string.format("%02x%02x%02x", r, g, b)
      end

      if include_background then
        -- If there's a background color, return format for "fg,bg"
        return "#" .. to_hex_part(rgb[1], rgb[2], rgb[3]) .. "," ..
            to_hex_part(bg[1], bg[2], bg[3])
      else
        -- Just foreground color
        return "#" .. to_hex_part(rgb[1], rgb[2], rgb[3])
      end
    end

    --- Converts an HSL colour to an RGB colour.
    --- @param hsl table - The HSL colour as a table with three elements: hue, saturation, and lightness.
    --- @return table - The RGB colour as a table with three elements: red, green, and blue.
    ---
    --- @example
    --- ```lua
    --- colour.hsl_to_rgb({180, 50, 50})
    --- -- {127, 127, 127}
    --- ```
    function self.hsl_to_rgb(hsl)
      ___.v.hsl_table(hsl, 1, false)

      local h, s, l = hsl[1] / 360, hsl[2] / 100, hsl[3] / 100

      local function hue_to_rgb(p, q, t)
        if t < 0 then t = t + 1 end
        if t > 1 then t = t - 1 end
        if t < 1 / 6 then return p + (q - p) * 6 * t end
        if t < 1 / 2 then return q end
        if t < 2 / 3 then return p + (q - p) * (2 / 3 - t) * 6 end
        return p
      end

      local r, g, b

      if s == 0 then
        r, g, b = l, l, l
      else
        local q = l < 0.5 and l * (1 + s) or l + s - l * s
        local p = 2 * l - q

        r = hue_to_rgb(p, q, h + 1 / 3)
        g = hue_to_rgb(p, q, h)
        b = hue_to_rgb(p, q, h - 1 / 3)
      end

      -- Ensure we return numbers
      return {
        math.floor(r * 255 + 0.5),
        math.floor(g * 255 + 0.5),
        math.floor(b * 255 + 0.5)
      }
    end

    --- Determines if a colour is a light colour.
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @return boolean - True if the colour is light, false otherwise.
    ---
    --- @example
    --- ```lua
    --- colour.is_light({255, 255, 255})
    --- -- true
    --- ```
    function self.is_light(rgb)
      ___.v.rgb_table(rgb, 1, false)

      local r = rgb[1] / 255
      local g = rgb[2] / 255
      local b = rgb[3] / 255
      local luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b
      return luminance > 0.5
    end

    --- Lightens or darkens a colour by a given amount.
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @param amount number - The amount to adjust the colour by.
    --- @param lighten boolean - Whether to lighten (true) or darken (false) the colour.
    --- @return table - The adjusted RGB colour as a table with three elements: red, green, and blue.
    function self.adjust_colour(rgb, amount, lighten)
      ___.v.rgb_table(rgb, 1, false)
      ___.v.type(amount, "number", 2, true)

      amount = ___.number.clamp(amount or 30, 0, 255)

      local direction = lighten and 1 or -1

      return {
        math.floor(___.number.clamp(rgb[1] + direction * amount, 0, 255)),
        math.floor(___.number.clamp(rgb[2] + direction * amount, 0, 255)),
        math.floor(___.number.clamp(rgb[3] + direction * amount, 0, 255))
      }
    end

    --- Lightens a colour by a given amount.
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @param amount number - The amount to lighten the colour by. (Optional, defaults to 30)
    --- @return table - The lightened RGB colour as a table with three elements: red, green, and blue.
    ---
    --- @example
    --- ```lua
    --- colour.lighten({100,100,100},50)
    --- -- {150, 150, 150}
    --- ```
    function self.lighten(rgb, amount)
      return self.adjust_colour(rgb, amount, true)
    end

    --- Darkens a colour by a given amount.
      ---
      --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
      --- @param amount number - The amount to darken the colour by. (Optional, defaults to 30)
      --- @return table - The darkened RGB colour as a table with three elements: red, green, and blue.
      ---
      --- @example
      --- ```lua
      --- colour.darken({100,100,100},50)
      --- -- {50, 50, 50}
    --- ```
    function self.darken(rgb, amount)
      return self.adjust_colour(rgb, amount, false)
    end

    --- Lightens or darkens the first colour by a given amount based on a comparison with the second colour.
    --- If the colours are already contrasting, the original colour is returned.
    --- @param rgb_compare table - The first RGB colour as a table with three elements: red, green, and blue.
    --- @param rgb_colour table - The second RGB colour as a table with three elements: red, green, and blue.
    --- @param amount number - The amount to lighten or darken the colour by. (Optional, defaults to 85)
    --- @return table - The adjusted RGB colour as a table with three elements: red, green, and blue. Unless the colours are already constrasted, in which case the original colour is returned.
    ---
    --- @example
    --- ```lua
    --- colour.lighten_or_darken({100,100,100}, {255,255,255}, 50)
    --- -- {100, 100, 100}
    ---
    --- -- If you want to a light or dark version of the same colour, you can use this:
    --- -- This is useful if you aren't sure what the colour is, but you want to
    --- -- have a contrasting shade.
    --- colour.lighten_or_darken({255,255,255}, {255,255,255}, 50)
    --- -- {205, 205, 205}
    --- ```
    function self.lighten_or_darken(rgb_colour, rgb_compare, amount)
      ___.v.type(amount, "number", 3, true)

      amount = amount or 85

      local colour_is_light = self.is_light(rgb_colour)
      local compare_is_light = self.is_light(rgb_compare)

      if colour_is_light and compare_is_light then
        return self.darken(rgb_colour, amount)
      elseif not colour_is_light and not compare_is_light then
        return self.lighten(rgb_colour, amount)
      else
        return rgb_colour
      end
    end

    --- Returns the complementary colour of a given colour.
    --- @example
    --- ```lua
    --- colour.complementary({ 150, 150, 150 })
    --- -- { 105, 105, 105 }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @return table - The complementary RGB colour as a table with three elements: red, green, and blue.
    function self.complementary(rgb)
      ___.v.rgb_table(rgb, 1, false)

      local hsl = self.rgb_to_hsl(rgb)
      -- Rotate hue by 180 degrees for true complement
      hsl[1] = (hsl[1] + 180) % 360

      return self.hsl_to_rgb(hsl)
    end

    --- Converts a colour to its grayscale equivalent.
    --- @example
    --- ```lua
    --- colour.grayscale({ 35, 50, 100 })
    --- -- { 62, 62, 62 }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @return table - The grayscale RGB colour as a table with three elements: red, green, and blue.
    function self.grayscale(rgb)
      ___.v.rgb_table(rgb, 1, false)

      local gray = math.floor((rgb[1] + rgb[2] + rgb[3]) / 3 + 0.5)
      return { gray, gray, gray }
    end

    --- Adjusts the saturation of a colour by a given factor.
    --- @example
    --- ```lua
    --- colour.adjust_saturation({ 35, 50, 100 }, 0.5)
    --- -- { 48, 55, 80 }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @param factor number - A factor between 0 (fully desaturated) and 1 (fully saturated).
    --- @return table - The adjusted RGB colour as a table with three elements: red, green, and blue.
    function self.adjust_saturation(rgb, factor)
      ___.v.rgb_table(rgb, 1, false)
      ___.v.type(factor, "number", 2, true)

      local gray = (rgb[1] + rgb[2] + rgb[3]) / 3

      return {
        math.floor(gray + (rgb[1] - gray) * factor),
        math.floor(gray + (rgb[2] - gray) * factor),
        math.floor(gray + (rgb[3] - gray) * factor)
      }
    end

    --- Generates a random RGB colour.
    --- @example
    --- ```lua
    --- colour.random()
    --- -- { 123, 45, 67 }
    --- ```
    --- @return table - A random RGB colour as a table with three elements: red, green, and blue.
    function self.random()
      return { math.random(0, 255), math.random(0, 255), math.random(0, 255) }
    end

    --- Generates a random shade of a given colour within a range.
    --- @example
    --- ```lua
    --- colour.random_shade({ 100, 100, 100 }, 50)
    --- -- { 150, 150, 150 }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @param range number - The range to adjust the colour by (e.g., 50 means +/- 50 for R, G, and B). (Optional, defaults to 50)
    --- @return table - A random RGB colour that is a shade of the given colour.
    function self.random_shade(rgb, range)
      ___.v.rgb_table(rgb, 1, false)
      ___.v.type(range, "number", 2, true)

      range = range or 50

      local r = math.random(math.max(0, rgb[1] - range), math.min(255, rgb[1] + range))
      local g = math.random(math.max(0, rgb[2] - range), math.min(255, rgb[2] + range))
      local b = math.random(math.max(0, rgb[3] - range), math.min(255, rgb[3] + range))
      return { r, g, b }
    end

    --- Generates the triad colours of a given colour. Does not return the
    --- original colour, but two returned colours that are considered tritones of
    --- the original colour.
    --- @example
    --- ```lua
    --- colour.triad({ 100, 100, 100 })
    --- -- { { 15, 204, 204 }, { 100, 204, 204 } }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @return table - A table of RGB colours that are the triad of the given colour.
    function self.triad(rgb)
      ___.v.rgb_table(rgb, 1, false)

      local hsl = self.rgb_to_hsl(rgb)
      -- Generate two colors 120 degrees apart in hue
      return {
        self.hsl_to_rgb({ (hsl[1] + 120) % 360, hsl[2], hsl[3] }),
        self.hsl_to_rgb({ (hsl[1] + 240) % 360, hsl[2], hsl[3] })
      }
    end

    --- Generates the analogous colours of a given colour.
    --- The analogous colours are generated by rotating the hue of the given
    --- colour by a given angle.
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @param angle number - The angle to separate the analogous colours by. (Optional, defaults to 30)
    --- @return table - A table of RGB colours that are analogous to the given colour.
    --- @example
    --- ```lua
    --- colour.analogous({ 100, 100, 100 })
    --- -- { { 70, 100, 100 }, { 100, 100, 100 }, { 130, 100, 100 } }
    --- ```
    function self.analogous(rgb, angle)
      ___.v.rgb_table(rgb, 1, false)
      ___.v.type(angle, "number", 2, true)

      angle = angle or 30 -- Default 30 degree separation
      local hsl = self.rgb_to_hsl(rgb)

      return {
        self.hsl_to_rgb({ (hsl[1] - angle) % 360, hsl[2], hsl[3] }),
        rgb, -- Original color in the middle
        self.hsl_to_rgb({ (hsl[1] + angle) % 360, hsl[2], hsl[3] })
      }
    end

    --- Generates the split complement colours of a given colour.
    --- @example
    --- ```lua
    --- colour.split_complement({ 100, 100, 100 })
    --- -- { { 15, 204, 204 }, { 100, 204, 204 } }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @param angle number - The angle to separate the split complement colours by. (Optional, defaults to 30)
    --- @return table - A table of RGB colours that are the split complement of the given colour.
    function self.split_complement(rgb, angle)
      ___.v.rgb_table(rgb, 1, false)
      ___.v.type(angle, "number", 2, true)

      angle = angle or 30 -- Default split angle
      local hsl = self.rgb_to_hsl(rgb)
      local complement_h = (hsl[1] + 180) % 360

      return {
        self.hsl_to_rgb({ (complement_h - angle) % 360, hsl[2], hsl[3] }),
        self.hsl_to_rgb({ (complement_h + angle) % 360, hsl[2], hsl[3] })
      }
    end

    --- Generates a series of monochromatic colours based on a given colour.
    --- @example
    --- ```lua
    --- colour.monochrome({ 100, 100, 100 })
    --- -- { { 100, 100, 100 }, { 100, 100, 100 }, { 100, 100, 100 } }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @param steps number - The number of variations to generate. (Optional, defaults to 5)
    --- @return table - A table of RGB colours that are monochromatic variations of the given colour.
    function self.monochrome(rgb, steps)
      ___.v.rgb_table(rgb, 1, false)
      ___.v.type(steps, "number", 2, true)

      steps = steps or 5 -- Default number of variations
      local hsl = self.rgb_to_hsl(rgb)
      local results = {}

      for i = 0, steps - 1 do
        -- Vary both lightness and saturation
        local s = ___.number.clamp(hsl[2] + (i - (steps / 2)) * 10, 0, 100)
        local l = ___.number.clamp(hsl[3] + (i - (steps / 2)) * 10, 0, 100)
        table.insert(results, self.hsl_to_rgb({ hsl[1], s, l }))
      end

      return results
    end

    --- Generates the tetrad colours of a given colour.
    --- @example
    --- ```lua
    --- colour.tetrad({ 100, 100, 100 })
    --- -- { { 100, 100, 100 }, { 100, 100, 100 }, { 100, 100, 100 }, { 100, 100, 100 } }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @return table - A table of RGB colours that are the tetrad of the given colour.
    function self.tetrad(rgb)
      ___.v.rgb_table(rgb, 1, false)

      local hsl = self.rgb_to_hsl(rgb)
      return {
        rgb, -- Original color
        self.hsl_to_rgb({ (hsl[1] + 90) % 360, hsl[2], hsl[3] }),
        self.hsl_to_rgb({ (hsl[1] + 180) % 360, hsl[2], hsl[3] }),
        self.hsl_to_rgb({ (hsl[1] + 270) % 360, hsl[2], hsl[3] })
      }
    end

    --- Calculates the contrast ratio between two colours.
    --- @example
    --- ```lua
    --- colour.contrast_ratio({ 100, 100, 100 }, { 0, 0, 0 })
    --- -- 12.0
    --- ```
    --- @param rgb1 table - The first RGB colour as a table with three elements: red, green, and blue.
    --- @param rgb2 table - The second RGB colour as a table with three elements: red, green, and blue.
    --- @return number - The contrast ratio between the two colours.
    function self.contrast_ratio(rgb1, rgb2)
      ___.v.rgb_table(rgb1, 1, false)
      ___.v.rgb_table(rgb2, 2, false)

      -- Convert RGB to relative luminance
      local function luminance(rgb)
        local r, g, b = rgb[1] / 255, rgb[2] / 255, rgb[3] / 255
        -- Convert RGB to linear space
        r = r <= 0.03928 and r / 12.92 or ((r + 0.055) / 1.055) ^ 2.4
        g = g <= 0.03928 and g / 12.92 or ((g + 0.055) / 1.055) ^ 2.4
        b = b <= 0.03928 and b / 12.92 or ((b + 0.055) / 1.055) ^ 2.4
        -- Calculate luminance
        return 0.2126 * r + 0.7152 * g + 0.0722 * b
      end

      local l1 = luminance(rgb1)
      local l2 = luminance(rgb2)
      local lighter = math.max(l1, l2)
      local darker = math.min(l1, l2)

      return (lighter + 0.05) / (darker + 0.05)
    end

    --- Calculates the contrasting colour based on the luminance of a given colour.
    --- @example
    --- ```lua
    --- colour.contrast({ 100, 100, 100 })
    --- -- { 0, 0, 0 }
    --- ```
    --- @param rgb table - The RGB colour as a table with three elements: red, green, and blue.
    --- @return table - The contrasting colour as a table with three elements: red, green, and blue.
    function self.contrast(rgb)
      ___.v.rgb_table(rgb, 1, false)

      -- Convert RGB to HSL
      local hsl = self.rgb_to_hsl(rgb)

      -- Invert the lightness to get the contrasting colour
      hsl[3] = 100 - hsl[3]

      -- Convert back to RGB
      return self.hsl_to_rgb(hsl)
    end
  end,
  -- Validations
  valid = function(___, self)
    return {
      rgb_table = function(colour, argument_index, nil_allowed)
        local last = ___.v.get_last_traceback_line()

        ___.v.type(colour, "table", argument_index, nil_allowed)
        assert(#colour == 3,
          "Invalid number of elements to argument " ..
          argument_index .. ". Expected 3, got " .. #colour .. " in\n" .. last)
        assert(type(colour[1]) == "number",
          "Invalid type to argument " ..
          argument_index .. ". Expected number, got " .. type(colour[1]) .. " in\n" .. last)
        assert(type(colour[2]) == "number",
          "Invalid type to argument " ..
          argument_index .. ". Expected number, got " .. type(colour[2]) .. " in\n" .. last)
        assert(type(colour[3]) == "number",
          "Invalid type to argument " ..
          argument_index .. ". Expected number, got " .. type(colour[3]) .. " in\n" .. last)
        assert(colour[1] >= 0 and colour[1] <= 255,
          "Invalid value to argument " ..
          argument_index .. ". Expected number between 0 and 255, got " .. colour[1] .. " in\n" .. last)
        assert(colour[2] >= 0 and colour[2] <= 255,
          "Invalid value to argument " ..
          argument_index .. ". Expected number between 0 and 255, got " .. colour[2] .. " in\n" .. last)
        assert(colour[3] >= 0 and colour[3] <= 255,
          "Invalid value to argument " ..
          argument_index .. ". Expected number between 0 and 255, got " .. colour[3] .. " in\n" .. last)
      end,
      hsl_table = function(hsl, argument_index, nil_allowed)
        local last = ___.v.get_last_traceback_line()

        ___.v.type(hsl, "table", argument_index, nil_allowed)
        assert(#hsl == 3, "Invalid number of elements to argument " .. argument_index ..
          ". Expected 3, got " .. #hsl .. " in\n" .. last)

        assert(type(hsl[1]) == "number",
          "Invalid type to argument " .. argument_index ..
          ". Expected number for hue, got " .. type(hsl[1]) .. " in\n" .. last)
        assert(type(hsl[2]) == "number",
          "Invalid type to argument " .. argument_index ..
          ". Expected number for saturation, got " .. type(hsl[2]) .. " in\n" .. last)
        assert(type(hsl[3]) == "number",
          "Invalid type to argument " .. argument_index ..
          ". Expected number for lightness, got " .. type(hsl[3]) .. " in\n" .. last)

        assert(hsl[1] >= 0 and hsl[1] <= 360,
          "Invalid value to argument " .. argument_index ..
          ". Expected hue between 0 and 360, got " .. hsl[1] .. " in\n" .. last)
        assert(hsl[2] >= 0 and hsl[2] <= 100,
          "Invalid value to argument " .. argument_index ..
          ". Expected saturation between 0 and 100, got " .. hsl[2] .. " in\n" .. last)
        assert(hsl[3] >= 0 and hsl[3] <= 100,
          "Invalid value to argument " .. argument_index ..
          ". Expected lightness between 0 and 100, got " .. hsl[3] .. " in\n" .. last)
      end,
      colour_name = function(colour, argument_index, nil_allowed)
        if nil_allowed and colour == nil then return end

        -- Extract the colour name if enclosed in <>
        local name = rex.match(colour, "<?([\\w_]+)>?") or colour

        ___.v.rgb_table(color_table[name], argument_index, nil_allowed)
      end
    }
  end
})


-- File: date.lua
local DateClass = Glu.glass.register({
  class_name = "DateClass",
  name = "date",
  dependencies = {},
  setup = function(___, self, opts)
    local v = ___.v

    function self.shms(seconds, as_string)
      v.type(seconds, "number", 1, false)
      v.type(as_string, "boolean", 2, true)

      local s = seconds or 0

      -- Handle negative seconds
      local is_negative = s < 0
      s = math.abs(s)

      -- Hours
      local hh = math.floor(s / (60 * 60))
      -- Minutes
      local mm = math.floor((s % (60 * 60)) / 60)
      -- Seconds
      local ss = s % 60

      if is_negative then
        -- Adjust for negative seconds
        if ss > 0 then
          ss = 60 - ss
          mm = mm + 1
        end

        if mm > 0 then
          mm = 60 - mm
          hh = (hh == 0) and 23 or (hh - 1)
        else
          hh = (hh == 0) and 23 or (hh - 1)
        end
      end

      if as_string then
        local r = {}
        if hh ~= 0 then
          r[#r + 1] = hh .. "h"
        end
        if mm ~= 0 then
          r[#r + 1] = mm .. "m"
        end
        if ss ~= 0 then
          r[#r + 1] = ss .. "s"
        end

        return table.concat(r, " ") or "0s"
      else
        local result_hours = string.format("%02d", hh)
        local result_minutes = string.format("%02d", mm)
        local result_seconds = string.format("%02d", ss)
        return result_hours, result_minutes, result_seconds
      end
    end
  end
})


-- File: dependency.lua
local DependencyClass = Glu.glass.register({
  class_name = "DependencyClass",
  name = "dependency",
  dependencies = { "queue", "table"},
  setup = function(___, self)
    self.queues = {}

    --- Install dependencies by including a table of tables that contains
    --- the name and URL of the package to install.
    ---
    --- The first failure will stop the installation process and call the
    --- callback.
    ---
    --- The callback is called with two arguments: a boolean indicating
    --- success or failure, and a message indicating the reason for the
    --- failure.
    ---
    --- @param packages table - A table of tables containing the name and URL of the package to install.
    --- @param cb function - A callback function that will be called when all dependencies are installed.
    --- @return table - A new instance of the DependencyQueue class.
    --- @example
    --- ```lua
    --- local packages = {
    ---   { name = "package1", url = "https://example.com/package1.mpackage" },
    ---   { name = "package2", url = "https://example.com/package2.mpackage" },
    --- }
    ---
    --- local cb = function(success, message)
    --- if success then
    ---   cecho("All dependencies installed successfully.\n")
    --- else
    ---   cecho(f"Failed to install dependencies: {message}\n")
    --- end
    ---
    --- local deps = dependency.new(packages, cb)
    --- deps:start()
    --- ```
    function self.new(packages, cb)
      local queue = ___.dependency_queue.new(packages, cb)
      ___.table.push(self.queues, queue)
      ---@diagnostic disable-next-line: return-type-mismatch
      return queue
    end
  end
})


-- File: dependency_queue.lua
local DependencyQueueClass = Glu.glass.register({
  class_name = "DependencyQueueClass",
  name = "dependency_queue",
  inherit_from = "queue",
  call = "new_dependency_queue",
  dependencies = {"queue", "table",},
  setup = function(___, self)
    function self.new_dependency_queue(packages, cb)
      local installed = getPackages()
      local not_installed = table.n_filter(packages, function(package)
        return ___.table.index_of(installed, package.name) == nil
      end) or {}

      -- We have no packages not installed, so just return as if we're done.
      if #not_installed == 0 then
        cecho("All dependencies are already installed.\n")
        cb(true, nil)
        return
      end

      local id = ___.id()
      ___.table.add(self, {
        id = id,
        cb = cb,
        packages = not_installed,
        handler_name = f "dependency_{id}_installed",
      })

      for _, package in ipairs(not_installed) do
        self.push(self.id, function()
          cecho(f "Installing dependency `<b>{package.name}</b>`...\n")
          installPackage(package.url)
        end)
      end

      registerNamedEventHandler("glu", self.handler_name, "sysInstall",
        function(event, package)
          if package ~= self.packages[1].name then return end

          ___.table.shift(self.packages)
          tempTimer(1, function()
            local q, count = self.queue.execute()
            if #self.packages == 0 then
              self.cb(true, nil)
              self.clean_up()
            end
          end)
        end
      )

      registerNamedEventHandler("glu", self.handler_name .. "_download_error", "sysDownloadError",
        function(event, package)
          self.cb(false, f "Failed to download dependency `<b>{package}</b>`.\nCleaning up.\n")
          self.clean_up()
        end
      )

      function self.clean_up()
        deleteNamedEventHandler("glu", self.handler_name)
        deleteNamedEventHandler("glu", self.handler_name .. "_download_error")
        self.handler_name = nil
        self.queue = nil
      end

      function self.start()
        self.execute()
      end
    end
  end
})


-- File: fd.lua
local FdClass = Glu.glass.register({
  class_name = "FdClass",
  name = "fd",
  dependencies = { "table"},
  setup = function(___, self)
    --- Splits a path into a directory and file.
    ---
    --- If the directory is required and does not exist, nil is returned.
    ---
    --- @example
    --- ```lua
    --- fd.dir_file("path/to/file.txt")
    --- -- "path/to", "file.txt"
    --- ```
    ---
    --- @param path string - The path to split.
    --- @param dir_required boolean - Whether the directory is required (Optional. Default is false).
    --- @return string|nil,string|nil - A table with the directory and file, or nil if the path is invalid.
    function self.dir_file(path, dir_required)
      ___.v.type(path, "string", 1, false)
      ___.v.type(dir_required, "boolean", 2, true)

      dir_required = dir_required or false

      path, _ = self.fix_path(path)

      local dir, file = rex.match(path, "^(.*)/(.*)$")
      if #{dir, file} == 2 then
        return dir, file
      end

      if dir_required and dir then
        if not self.dir_exists(dir) then
          return nil, nil
        end
      end

      return dir, file
    end

    function self.root_dir_file(path)
      ___.v.type(path, "string", 1, false)

      local root = self.determine_root(path)
      if not root then return nil, nil, nil end

      local len = utf8.len(root)
      local dir, file = self.dir_file(path:sub(len + 1))
      if not dir then return nil, nil, nil end

      return root, dir, file
    end

    --- Checks if a file exists.
    --- @param path string - The path to check.
    --- @return boolean - Whether the file exists.
    --- @example
    --- ```lua
    --- fd.file_exists("path/to/file.txt")
    --- -- true
    --- ```
    function self.file_exists(path)
      ___.v.type(path, "string", 1, false)

      local attr, message, code = lfs.attributes(path)
      if not attr then return false end

      return attr.mode == "file"
    end

    --- Checks if a directory exists.
    --- @param path string - The path to check.
    --- @return boolean - Whether the directory exists.
    --- @example
    --- ```lua
    --- fd.dir_exists("path/to/directory")
    --- -- true
    --- ```
    function self.dir_exists(path)
      ___.v.type(path, "string", 1, false)

      local attr, message, code = lfs.attributes(path)
      if not attr then return false end

      return attr.mode == "directory"
    end

    --- Reads a file.
    --- @param path string - The path to the file.
    --- @param binary boolean - Whether the file is binary (default false).
    --- @return ... any - The contents of the file.
    --- @example
    --- ```lua
    --- fd.read_file("path/to/file.txt")
    --- -- "contents of file"
    --- ```
    function self.read_file(path, binary)
      ___.v.type(path, "string", 1, false)
      ___.v.type(binary, "boolean", 2, true)

      local handle, error, code = io.open(path, "r" .. (binary and "b" or ""))
      if not handle then return nil, error, code end

      local data = handle:read("*a")
      handle:close()

      return data
    end

    --- Writes to a file.
    --- @param path string - The path to the file.
    --- @param data string - The data to write to the file.
    --- @param overwrite boolean - Whether to overwrite the file (default false).
    --- @param binary boolean - Whether the file is binary (default false).
    --- @return string|table - The path to the file or nil, a table with the error and code, or the attributes of the file.
    --- @example
    --- ```lua
    --- fd.write_file("path/to/file.txt", "contents of file")
    --- -- "path/to/file.txt", "contents of file", nil
    --- ```
    function self.write_file(path, data, overwrite, binary)
      ___.v.type(path, "string", 1, false)
      ___.v.type(data, "string", 2, false)
      ___.v.type(overwrite, "boolean", 3, true)
      ___.v.type(binary, "boolean", 4, true)

      path = self.fix_path(path)

      local flag = overwrite and "w" or "a"
      local mode = binary and "b" or ""
      local handle, error, code = io.open(path, flag .. mode)
      if not handle then return nil, { error = error, code = code } end

      handle:write(data)
      handle:flush()
      handle:close()

      return path, lfs.attributes(path)
    end

    --- Fixes a path to use forward slashes.
    --- @param path string - The path to fix.
    --- @return string, number - The fixed path and the number of replacements made.
    --- @example
    --- ```lua
    --- fd.fix_path("path\\to\\file.txt")
    --- -- "path/to/file.txt"
    --- ```
    function self.fix_path(path)
      ___.v.type(path, "string", 1, false)

      local result, num = rex.gsub(rex.gsub(path, "\\\\", "/"), "//", "/")
      if not result or num == 0 then return path, 0 end

      if result:sub(-1) == "/" then
        result = result:sub(1, -2) or ""
      end

      ---@diagnostic disable-next-line: return-type-mismatch
      return result, num
    end

    function self.determine_path_separator(path)
      ___.v.type(path, "string", 1, false)

      for _, sep in ipairs({ "/", "\\" }) do
        if path:find(sep) then return sep end
      end

      return nil
    end

    function self.valid_path_string(path)
      ___.v.type(path, "string", 1, false)

      return self.determine_path_separator(path) ~= nil
    end

    function self.valid_path_table(paths)
      ___.v.indexed(paths, "table", 1, false)

      return ___.table.all(paths, self.valid_path_string)
    end

    function self.valid_path_table_or_string(path)
      path = ___.table.n_cast(path)

      ___.v.indexed(path, "table", 1, false)

      if type(path) == "string" then
        return self.valid_path_string(path)
      elseif type(path) == "table" then
        return self.valid_path_table(path)
      end

      return false
    end

    function self.valid_path(path)
      ___.v.type(path, "string", 1, false)

      return self.dir_exists(path) or self.file_exists(path)
    end

    function self.valid_paths(paths)
      ___.v.n_uniform(paths, "string", 1, false)

      return ___.table.all(paths, self.valid_path)
    end

    function self.valid_path_table(paths)
      ___.v.indexed(paths, "table", 1, false)

      return ___.table.all(paths, self.valid_path)
    end

    --- Ensures that a directory exists.
    --- @param path string - The path to the directory.
    --- @return table|nil, string|nil, number|nil - A table of created directories, the error message, and the error code.
    --- @example
    --- ```lua
    --- fd.assure_dir("path/to/directory")
    --- ```
    function self.assure_dir(path)
      ___.v.type(path, "string", 1, false)

      local sep = self.determine_path_separator(path)

      path = self.fix_path(path)
      path = ___.string.append(path, sep)
      local root
      root, path, _ = self.root_dir_file(path)
      if path[1] == sep then path = path:sub(2) end

      local dirs = path:split(sep)
      local target = root
      dirs = table.n_filter(dirs, function(dir) return dir ~= "" end)

      local created = {}
      repeat
        local dir = table.remove(dirs, 1)
        target = ___.string.append(target, dir) .. sep

        if not self.dir_exists(target) then
          local ok, err, code = lfs.mkdir(target)
          if not ok and err and code ~= 17 then return nil, err, code end
          table.insert(created, target)
        end
      until #dirs == 0
      created = ___.table.map(created, function(_, dir) return self.fix_path(dir) end)
      return created, nil, nil
    end

    --- Determines the root of a path.
    --- @param path string - The path to determine the root of.
    --- @return string|nil - The root of the path, or nil if the path is invalid.
    --- @example
    --- ```lua
    --- fd.determine_root("c:\\test\\moo")
    --- -- "c:"
    --- ```
    function self.determine_root(path)
      ___.v.type(path, "string", 1, false)

      path, _ = self.fix_path(path)

      local parts = {rex.match(path, "^([a-zA-Z]:(\\\\{1,2}|/{1,2})|/{1,2})(?:.*)$")}
      if not parts then return nil end

      local root, slash = parts[1], parts[2] or ""

      return root
    end

    --- Removes a file.
    --- @param path string - The path to the file.
    --- @return boolean|nil, nil|string - Whether the file was removed, or nil and the error message.
    --- @example
    --- ```lua
    --- fd.rmfile("path/to/file.txt")
    --- -- true
    --- ```
    function self.rmfile(path)
      ___.v.file(path, 1)

      return os.remove(path)
    end

    --- Removes a directory.
    --- @param path string - The path to the directory.
    --- @return boolean|nil, nil|string - Whether the directory was removed, or nil and the error message.
    --- @example
    --- ```lua
    --- fd.rmdir("path/to/directory")
    --- -- true
    --- ```
    function self.rmdir(path)
      ___.v.dir(path, 1)

      return lfs.rmdir(path)
    end

    --- Checks if a directory is empty.
    --- @param path string - The path to the directory.
    --- @return boolean - Whether the directory is empty.
    --- @example
    --- ```lua
    --- fd.dir_empty("/path/to/directory")
    --- -- true
    --- ```
    function self.dir_empty(path)
      return #self.get_dir(path, false) == 0
    end

    --- Gets the files in a directory.
    --- @param path string - The path to the directory.
    --- @param include_dots boolean - Whether to include the "." and ".." directories (default false).
    --- @return table - A table of files in the directory.
    --- @example
    --- ```lua
    --- fd.get_dir("/path/to/directory")
    --- -- {"file1", "file2", "file3"}
    --- ```
    function self.get_dir(path, include_dots)
      ___.v.type(path, "string", 1, false)
      ___.v.type(include_dots, "boolean", 2, true)

      include_dots = include_dots or false

      path, _ = self.fix_path(path)
      path = path or ""

      ___.v.dir(path, 1)

      local result = {}

      for file in lfs.dir(path) do
        local attr = lfs.attributes(path .. "/" .. file)
        table.insert(result, file)
      end

      if not include_dots then
        result = table.n_filter(result, function(file) return file ~= "." and file ~= ".." end)
      end

      ---@diagnostic disable-next-line: return-type-mismatch
      return result
    end

    function self.temp_dir()
      local dir = getMudletHomeDir() .. "/tmp/" .. ___.id()

      local ok, err, code = self.assure_dir(dir)
      if not ok then return nil, err, code end

      return dir
    end
  end,
  valid = function(___, self)
    return {
      file = function(path, argument_index)
        ___.v.type(path, "string", argument_index, false)
        ___.v.type(argument_index, "number", 2, false)

        local attr = lfs.attributes(path)
        local last = ___.get_last_traceback_line()
        assert(attr ~= nil and attr.mode == "file", "Invalid value. " ..
          "Expected file, got " .. path .. " in\n" .. last)
      end,

      dir = function(path, argument_index)
        ___.v.type(path, "string", argument_index, false)
        ___.v.type(argument_index, "number", 2, false)

        local attr = lfs.attributes(path)
        local last = ___.get_last_traceback_line()
        assert(attr ~= nil and attr.mode == "directory", "Invalid value. " ..
          "Expected directory, got " .. path .. " in\n" .. last)
      end,

      path_string = function(path, argument_index, allow_nil)
        ___.v.type(path, "string", argument_index, false)
        ___.v.type(argument_index, "number", 2, false)
        ___.v.type(allow_nil, "boolean", 3, true)

        if allow_nil and path == nil then return end

        assert(self.valid_path_string(path), "Invalid value. " ..
          "Expected valid path string, got " .. path .. " in\n" ..
            ___.get_last_traceback_line())
      end,

      path_table = function(paths, argument_index, allow_nil)
        ___.v.uniform(paths, "string", 1, false)
        ___.v.type(allow_nil, "boolean", 2, true)

        allow_nil = allow_nil or false
        if allow_nil and #paths == 0 then return end

        assert(self.valid_path_table(paths), "Invalid value. " ..
          "Expected valid path table, got " .. ___.table.to_string(paths) ..
            " in\n" .. ___.get_last_traceback_line())
      end
    }
  end
})


-- File: func.lua
local FuncClass = Glu.glass.register({
  name = "func",
  class_name = "FuncClass",
  dependencies = {},
  setup = function(___, self)
    function self.delay(func, delay, ...)
      ___.v.type(func, "function", 1, false)
      ___.v.type(delay, "number", 2, false)

      ---@diagnostic disable-next-line: return-type-mismatch
      return tempTimer(delay, function(...)
        func(...)
      end)
    end

    function self.wrap(func, wrapper)
      --- ```lua
      --- local becho = function.wrap(cecho, function(func, text)
      ---   func("<b>{text}</b>")
      --- end)
      ---
      --- becho("Hello, world!")
      --- -- <b>Hello, world!</b>
      --- ```
      ___.v.type(func, "function", 1, false)
      ___.v.type(wrapper, "function", 2, false)

      return function(...)
        return wrapper(func, ...)
      end
    end

    function self.repeater(func, interval, times, ...)
      ___.v.type(func, "function", 1, false)
      ___.v.type(interval, "number", 2, true)
      ___.v.type(times, "number", 3, true)

      interval = interval or 1
      times = times or 1

      local count = 0
      local function _repeat(...)
        if count < times then
          func(...)
          count = count + 1
          tempTimer(interval, _repeat, ...)
        end
      end
      _repeat(...)
    end
  end
})


-- File: http.lua
local HttpClass = Glu.glass.register({
  name = "http",
  class_name = "HttpClass",
  dependencies = { "table" },
  setup = function(___, self)
    local function validate_options(options)
      ___.v.type(options, "table", 1, false)
      ___.v.not_empty(options, 1, false)
      ___.v.type(options.method, "string", 2, false)
      ___.v.regex(options.url, ___.regex.http_url, "url", 1, false)
      ___.v.type(options.callback, "function", 1, false)
    end

    self.http_types = { "GET", "PUT", "POST", "DELETE" }

    local requests = {}

    --- Downloads a file from the given URL and saves it to the specified path.
    --- You may certainly also use the `get` or `request` methods to download a
    --- file, however, this is a bit more convenient as it does some checking
    --- for you.
    ---
    --- @param options table - The options for the request.
    --- @param cb function - The callback function.
    --- @return table - The HTTP request object.
    --- @example
    --- ```lua
    --- http.download({
    ---   url = "http://example.com/file.txt",
    ---   saveTo = "path/to/file.txt"
    --- }, function(response) end)
    --- ```
    function self.download(options, cb)
      options.method = options.method or "GET"
      ___.v.type(options.saveTo, "string", 1, false)
      return self.request(options, cb)
    end

    --- Makes a GET request to the given URL.
    ---
    --- The options table may consist of the following keys:
    ---
    --- - `url` (`string`) - The URL to request.
    --- - `headers` (`table`) - The headers to send with the request.
    ---
    --- @param options table - The options for the request.
    --- @param cb function - The callback function.
    --- @return table - The HTTP request object.
    --- @example
    --- ```lua
    --- http.get({
    ---   url = "http://example.com/file.txt"
    --- }, function(response) end)
    --- ```
    function self.get(options, cb)
      options.method = "GET"
      return self.request(options, cb)
    end

    --- Makes a POST request to the given URL.
    ---
    --- The options table may consist of the following keys:
    ---
    --- - `url` (`string`) - The URL to request.
    --- - `headers` (`table`) - The headers to send with the request.
    ---
    --- @param options table - The options for the request.
    --- @param cb function - The callback function.
    --- @return table - The HTTP request object.
    --- @example
    --- ```lua
    --- http.post({
    ---   url = "http://example.com/file.txt"
    --- }, function(response) end)
    --- ```
    function self.post(options, cb)
      options.method = "POST"
      return self.request(options, cb)
    end

    --- Makes a PUT request to the given URL.
    ---
    --- The options table may consist of the following keys:
    ---
    --- - `url` (`string`) - The URL to request.
    --- - `headers` (`table`) - The headers to send with the request.
    ---
    --- @param options table - The options for the request.
    --- @param cb function - The callback function.
    --- @return table - The HTTP request object.
    --- @example
    --- ```lua
    --- http.put({
    ---   url = "http://example.com/file.txt"
    --- }, function(response) end)
    --- ```
    function self.put(options, cb)
      options.method = "PUT"
      return self.request(options, cb)
    end

    --- Makes a DELETE request to the given URL.
    ---
    --- The options table may consist of the following keys:
    ---
    --- - `url` (`string`) - The URL to request.
    --- - `headers` (`table`) - The headers to send with the request.
    ---
    --- @param options table - The options for the request.
    --- @param cb function - The callback function.
    --- @return table - The HTTP request object.
    --- @example
    --- ```lua
    --- http.delete({
    ---   url = "http://example.com/file.txt"
    --- }, function(response) end)
    --- ```
    function self.delete(options, cb)
      options.method = "DELETE"
      return self.request(options, cb)
    end

    --- Makes a request to the given URL. Use this option for any HTTP method
    --- that is not: `GET`, `POST`, `PUT`, or `DELETE`.
    ---
    --- The options table may consist of the following keys:
    ---
    --- - `url` (`string`) - The URL to request.
    --- - `method` (`string`) - The HTTP method to use.
    --- - `headers` (`table`) - The headers to send with the request.
    ---
    --- @param options table - The options for the request.
    --- @param cb function|nil - The callback function.
    --- @return table - The HTTP request object.
    --- @example
    --- ```lua
    --- http.request({
    ---   url = "http://example.com/file.txt"
    --- }, function(response) end)
    --- ```
    function self.request(options, cb)
      ___.v.type(options, "table", 1, false)
      ___.v.not_empty(options, 1, false)

      options.callback = options.callback or cb

      validate_options(options)

      -- upper case the method
      options.method = string.upper(options.method)

      -- Get a new http request object
      local gl = ___.getGlass("http_request")
      local request = gl(options, self).execute()
      table.insert(requests, request)
      return request
    end

    function self.delete_request(id)
      for i = 1, #requests do
        if requests[i].id == id then
          table.remove(requests, i)
          break
        end
      end
    end

    function self.find_request(id)
      for _, request in ipairs(requests) do
        if request.id == id then
          return request
        end
      end
      return nil
    end
  end
})


-- File: http_request.lua
local HttpRequestClass = Glu.glass.register({
  name = "http_request",
  class_name = "HttpRequestClass",
  dependencies = { "table", },
  setup = function(___, self, options)
    self.options = options

    function self.execute()
      local owner = self.container

      self.id = ___.id()

      -- Headers
      if not self.options.headers then self.options.headers = {} end
      if type(self.options.headers) ~= "table" then
        error("headers must be a table")
      end

      self.headers = self.options.headers

      local function done(response_data)
        local ob_id = response_data.id
        local ob = owner.find_request(ob_id)

        local result = {}
        if self.options.saveTo and not response_data.error then
          result.write = { ___.fd.write_file(self.options.saveTo, response_data.data) }
        end

        local cb = self.options.callback
        local gl = ___.getGlass("http_response")
        local response = gl(response_data, owner)

        cb(response)
        deleteAllNamedEventHandlers(ob_id)
        owner.delete_request(ob_id)
        ob = nil
        response_data = nil
      end

      -- Events to listen for
      local events = {}
      local lc = table.index_of(owner.http_types, self.options.method) and
          string.lower(self.options.method) or "custom"
      local uc = string.title(___.string.capitalize(lc))

      for _, event in ipairs({ "Done", "Error" }) do
        local event_mod = string.format("sys%sHttp%s", uc, event)
        table.insert(events, { event, event_mod })
      end

      local function only_indexed(t)
        local tmp = {}
        for i = 1, #t do
          tmp[i] = t[i]
        end
        return tmp
      end

      for _, event in ipairs(events) do
        local event_type, event_name = unpack(event)
        registerNamedEventHandler(
          self.id,
          event_name,
          event_name,
          function(e, ...)
            local response = {
              event = e,
              id = self.id,
            }

            local result
            arg = only_indexed(arg)
            if rex.match(e, "sys(?:\\w+)HttpError$") then
              result = ___.table.allocate({ "error", "url", "server" }, arg)
            elseif rex.match(e, "sys(?:\\w+)HttpDone$") then
              result = ___.table.allocate({ "url", "data", "server" }, arg)
            else
              error("Unknown event: " .. e)
            end

            ___.table.add(response, result)

            done(response)
          end
        )
      end

      self.method_lc = lc
      self.method_uc = uc
      self.custom = self.options.method == "CUSTOM"

      local func_name = string.format("%sHTTP", lc)
      local func = _G[func_name]

      assert(func, "HTTP method " .. func_name .. " not found")
      assert(type(func) == "function", "HTTP method " .. func_name .. " is not a function")

      local ok, err, result = pcall(
        self.custom and
        function() return func(self.options.method, self.options.url, self.options.headers) end or
        function() return func(self.options.url, self.options.headers) end
      )

      if not ok then
        error("Error calling HTTP method " .. tostring(self.custom) .. " " .. tostring(func) .. ": " .. tostring(err))
      end
      return self
    end
  end
})


-- File: http_response.lua
local HttpResponseClass = Glu.glass.register({
  name = "http_response",
  class_name = "HttpResponseClass",
  dependencies = { "table" },
  setup = function(___, self, response)
    self.id = response.id
    self.result = response
  end
})


-- File: number.lua
local NumberClass = Glu.glass.register({
  name = "number",
  class_name = "NumberClass",
  dependencies = { "table" },
  setup = function(___, self)
    --- Rounds a number to a specified number of decimal places.
    ---
    --- @param num number - The number to round.
    --- @param digits number - The number of digits to round to. (Optional. Default is 0.)
    --- @return number - The rounded number.
    --- @example
    --- ```lua
    --- number.round(3.14159, 2)
    --- -- 3.14
    --- ```
    function self.round(num, digits)
      ___.v.type(num, "number", 1, false)
      ___.v.type(digits, "number", 2, true)

      digits = digits or 0

      local mult = 10 ^ digits
      return math.floor(num * mult + 0.5) / mult
    end

    --- Clamps a number within a range.
      --- @param num number - The number to clamp.
      --- @param min number - The minimum allowed value.
      --- @param max number - The maximum allowed value.
      --- @return number - The clamped number.
      --- @example
      --- ```lua
      --- number.clamp(10, 1, 100)
      --- -- 10
      --- ```
    function self.clamp(num, min, max)
      ___.v.type(num, "number", 1, false)
      ___.v.type(min, "number", 2, false)
      ___.v.type(max, "number", 3, false)

      return math.max(min, math.min(num, max))
    end

    --- Linearly interpolates between two numbers.
      --- @param a number - The starting value.
      --- @param b number - The ending value.
      --- @param t number - The interpolation factor (between 0 and 1).
      --- @return number - The interpolated value.
      --- @example
      --- ```lua
      --- number.lerp(0, 100, 0.5)
      --- -- 50
      --- ```
    function self.lerp(a, b, t)
      ___.v.type(a, "number", 1, false)
      ___.v.type(b, "number", 2, false)
      ___.v.type(t, "number", 3, false)
      ___.v.test(t >= 0 and t <= 1, t, 3, false, "Interpolation factor should be between 0 and 1")

      return a + (b - a) * t
    end

    --- Smoothly interpolates between two numbers using a cubic function.
    --- @param start number - The starting value.
    --- @param end_val number - The ending value.
    --- @param t number - The interpolation factor (between 0 and 1).
    --- @return number - The interpolated value.
    --- @example
    --- ```lua
    --- number.lerp_smooth(0, 100, 0.5)
    --- -- 50
    --- ```
    function self.lerp_smooth(start, end_val, t)
      ___.v.type(start, "number", 1, false)
      ___.v.type(end_val, "number", 2, false)
      ___.v.type(t, "number", 3, false)
      ___.v.test(t >= 0 and t <= 1, t, 3, false)

      -- Smooth step (cubic)
      t = t * t * (3 - 2 * t)
      return start + (end_val - start) * t
    end

    --- Smoothly interpolates between two numbers using a quintic function.
    --- @param start number - The starting value.
    --- @param end_val number - The ending value.
    --- @param t number - The interpolation factor (between 0 and 1).
    --- @return number - The interpolated value.
    --- @example
    --- ```lua
    function self.lerp_smoother(start, end_val, t)
      ___.v.type(start, "number", 1, false)
      ___.v.type(end_val, "number", 2, false)
      ___.v.type(t, "number", 3, false)
      ___.v.test(t >= 0 and t <= 1, t, 3, false)

      -- Smoother step (quintic)
      t = t * t * t * (t * (t * 6 - 15) + 10)
      return start + (end_val - start) * t
    end

    --- Eases a number in towards a target value.
    --- @param start number - The starting value.
    --- @param end_val number - The target value.
    --- @param t number - The interpolation factor (between 0 and 1).
    --- @return number - The eased value.
    --- @example
    --- ```lua
    function self.lerp_ease_in(start, end_val, t)
      ___.v.type(start, "number", 1, false)
      ___.v.type(end_val, "number", 2, false)
      ___.v.type(t, "number", 3, false)
      ___.v.test(t >= 0 and t <= 1, t, 3, false)

      -- Quadratic ease in
      t = t * t
      return start + (end_val - start) * t
    end

    --- Eases a number out towards a target value.
    --- @param start number - The starting value.
    --- @param end_val number - The target value.
    --- @param t number - The interpolation factor (between 0 and 1).
    --- @return number - The eased value.
    --- @example
    --- ```lua
    function self.lerp_ease_out(start, end_val, t)
      ___.v.type(start, "number", 1, false)
      ___.v.type(end_val, "number", 2, false)
      ___.v.type(t, "number", 3, false)
      ___.v.test(t >= 0 and t <= 1, t, 3, false)

      -- Quadratic ease out
      t = t * (2 - t)
      return start + (end_val - start) * t
    end

    --- Maps a number from one range to another.
    --- @param value number - The input number.
    --- @param in_min number - The minimum of the input range.
    --- @param in_max number - The maximum of the input range.
    --- @param out_min number - The minimum of the output range.
    --- @param out_max number - The maximum of the output range.
    --- @return number - The mapped number.
    --- @example
    --- ```lua
    --- number.map(50, 0, 100, 0, 100)
    --- -- 50
    --- ```
    function self.map(value, in_min, in_max, out_min, out_max)
      ___.v.type(value, "number", 1, false)
      ___.v.type(in_min, "number", 2, false)
      ___.v.type(in_max, "number", 3, false)
      ___.v.type(out_min, "number", 4, false)
      ___.v.type(out_max, "number", 5, false)

      return (value - in_min) * (out_max - out_min) / (in_max - in_min) + out_min
    end

    --- Tests a number to see if it is positive, negative, or zero.
    --- @param num number - The number to check.
    --- @return boolean - True if the number is positive, false otherwise.
    --- @example
    --- ```lua
    --- number.positive(10)
    --- -- true
    --- ```
    function self.positive(num)
      ___.v.type(num, "number", 1, false)

      return num > 0
    end

    --- Checks if two numbers are approximately equal within a percentage tolerance.
    --- @param a number - The first number.
    --- @param b number - The second number.
    --- @param percent_tolerance number - The percentage allowed difference (default is 5%).
    --- @return boolean - True if the numbers are approximately equal, false otherwise.
    --- @example
    --- ```lua
    --- number.is_approximate(10, 11, 10)
    --- -- true
    --- ```
    function self.is_approximate(a, b, percent_tolerance)
      ___.v.type(a, "number", 1, false)
      ___.v.type(b, "number", 2, false)
      ___.v.type(percent_tolerance, "number", 3, true)

      percent_tolerance = percent_tolerance or 5 -- Default to 5%
      local tolerance = math.abs(a) * (percent_tolerance / 100)
      return math.abs(a - b) <= tolerance
    end

    --- Returns the minimum value in a list of numbers or a table.
    --- @param ... number|table[] - Either a list of numbers or a single table of numbers.
    --- @return number - The minimum value.
    --- @example
    --- ```lua
    --- number.min(1, 2, 3)
    --- -- 1
    --- ```
    function self.min(...)
      local args = ___.table.n_cast(...)
      ___.v.n_uniform(args, "number", 1, false)

      -- Calculate the minimum value
      local result = math.huge
      for _, num in ipairs(args) do
        result = math.min(result, num)
      end

      return result
    end

    --- Returns the maximum value in a list of numbers or a table of numbers.
    --- @param ... number|number[] - Either a list of numbers or a single table of numbers.
    --- @return number - The maximum value.
    --- @example
    --- ```lua
    --- number.max(1, 2, 3)
    --- -- 3
    --- ```
    function self.max(...)
      local args = ___.table.n_cast(...)
      ___.v.n_uniform(args, "number", 1, false)

      -- Calculate the maximum value
      local result = -math.huge
      for _, num in ipairs(args) do
        result = math.max(result, num)
      end

      return result
    end

    --- Sums a list of numbers.
    --- @param ... number[] - The numbers to sum.
    --- @return number - The sum of the numbers.
    --- @example
    --- ```lua
    --- number.sum(1, 2, 3)
    --- -- 6
    --- ```
    function self.sum(...)
      local args = ___.table.n_cast(...)
      ___.v.n_uniform(args, "number", 1, false)
      return ___.table.n_reduce(args, function(acc, num) return acc + num end, 0)
    end

    --- Returns a random number between a minimum and maximum value.
    --- @param min number - The minimum value.
    --- @param max number - The maximum value.
    --- @return number - The random number.
    --- @example
    --- ```lua
    --- number.random_clamp(0, 100)
    --- -- 50
    --- ```
    function self.random_clamp(min, max)
      ___.v.type(min, "number", 1, false)
      ___.v.type(max, "number", 2, false)

      return math.random() * (max - min) + min
    end

    --- Checks if a number is between two values (inclusive)
    --- @param num number - The number to check
    --- @param min number - The minimum value
    --- @param max number - The maximum value
    --- @return boolean - True if the number is between min and max
    --- @example
    --- ```lua
    --- number.is_between(5, 1, 10)
    --- -- true
    --- ```
    function self.is_between(num, min, max)
      ___.v.type(num, "number", 1, false)
      ___.v.type(min, "number", 2, false)
      ___.v.type(max, "number", 3, false)

      return num >= min and num <= max
    end

    --- @param num number - The number to check
    --- @return number - The sign (-1, 0, or 1)
    --- @example
    --- ```lua
    --- number.sign(-5)
    --- -- -1
    --- ```
    function self.sign(num)
      ___.v.type(num, "number", 1, false)

      return num > 0 and 1 or (num < 0 and -1 or 0)
    end

    --- Calculates the average (mean) of a list of numbers
    --- @param ... number|number[] - Either a list of numbers or a single table of numbers
    --- @return number - The average value
    --- @example
    --- ```lua
    --- number.average(1, 2, 3)
    --- -- 2
    --- ```
    function self.average(...)
      local args = ___.table.n_cast(...)
      local values

      if #args == 1 and type(args[1]) == "table" then
        values = args[1]
      elseif #args > 1 then
        values = args
      else
        error("Invalid argument type: expected a table or multiple numbers")
      end

      ___.v.n_uniform(values, "number", 1, false)
      return self.sum(values) / #values
    end

    --- Constrains a number to a certain precision
    --- @param num number - The number to constrain
    --- @param precision number - The precision (e.g., 0.1, 0.01, etc.)
    --- @return number - The constrained number
    --- @example
    --- ```lua
    --- number.constrain(3.14159, 0.01)
    --- -- 3.14
    --- ```
    function self.constrain(num, precision)
      ___.v.type(num, "number", 1, false)
      ___.v.type(precision, "number", 2, false)

      return math.floor(num / precision + 0.5) * precision
    end

    --- Calculates what percentage one number is of another
    --- @param value number - The current value
    --- @param total number - The total value
    --- @param round_digits? number - Optional number of decimal places to round to
    --- @return number - The percentage
    --- @example
    --- ```lua
    --- number.percent_of(25, 20)
    --- -- 5
    --- ```
    function self.percent_of(numerator, denominator, round_digits)
      ___.v.type(numerator, "number", 1, false)
      ___.v.type(denominator, "number", 2, false)
      ___.v.type(round_digits, "number", 3, true)

      local result = (numerator * 100) / denominator
      if round_digits then
        return self.round(result, round_digits)
      end
      return result
    end

    --- Calculates what number is a certain percentage of another
    --- @param percent number - The percentage
    --- @param total number - The total value
    --- @param round_digits? number - Optional number of decimal places to round to
    --- @return number - The resulting value
    --- @example
    --- ```lua
    --- number.percent(25, 100)
    --- -- 25
    --- number.percent(5, 20)
    --- -- 1
    --- ```
    function self.percent(percent, total, round_digits)
      ___.v.type(percent, "number", 1, false)
      ___.v.type(total, "number", 2, false)
      ___.v.type(round_digits, "number", 3, true)

      local result = (percent * total) / 100
      if round_digits then
        return self.round(result, round_digits)
      end
      return result
    end

    --- Normalizes a number to a 0-1 range
    --- @param num number - The number to normalize
    --- @param min number - The minimum value of the range
    --- @param max number - The maximum value of the range
    --- @return number - The normalized value (0-1)
    --- @example
    --- ```lua
    --- number.normalize(50, 0, 100)
    --- -- 0.5
    --- ```
    function self.normalize(num, min, max)
      return self.map(num, min, max, 0, 1)
    end

    --- Calculates the arithmetic mean of a list of numbers
    --- @param ... number|number[] - Either a list of numbers or a single table of numbers
    --- @return number - The arithmetic mean
    --- @example
    --- ```lua
    --- number.mean(1, 2, 3)
    --- -- 2
    --- ```
    function self.mean(...)
      local args = ___.table.n_cast(...)
      local values

      if #args == 1 and type(args[1]) == "table" then
        values = args[1]
      elseif #args > 1 then
        values = args
      else
        error("Invalid argument type: expected a table or multiple numbers")
      end

      ___.v.n_uniform(values, "number", 1, false)
      return self.sum(values) / #values
    end
  end,
  valid = function(___, self)
    return {
      range = function(value, min, max, argument_index, nil_allowed)
        if nil_allowed and value == nil then
          return
        end

        local last = ___.v.get_last_traceback_line()
        assert(value >= min and value <= max, "Invalid value to argument " ..
          argument_index .. ". Expected " .. min .. " to " .. max .. ", " ..
          "got " .. value .. " in\n" .. last)
      end
    }
  end
})


-- File: queue.lua
local QueueClass = Glu.glass.register({
  name = "queue",
  class_name = "QueueClass",
  dependencies = { "table" },
  setup = function(___, self)
    self.queues = {}

    --- Instantiates a new queue object and adds it to the list of queues.
    --- The object will contain a property that is the ID may be used to
    --- manipulate the queue. The same functionality to manipulate the queue
    --- is available both through the queue object and the functions from
    --- this module. The ID is in the form of a v4 UUID.
    ---
    --- @param funcs table - A table of functions to be added to the queue
    --- @return table - The new queue object
    ---
    --- @example
    --- ```lua
    --- local queue = queue.new(parent).new({})
    --- ```
    function self.new(funcs)
      ___.v.type(funcs, "table", 1, true)
      ___.v.n_uniform(funcs, "function", 1, false)

      funcs = funcs or {}
      local queue = ___.queue_stack(funcs, self)
      ___.table.push(self.queues, queue)

      ---@diagnostic disable-next-line: return-type-mismatch
      return queue
    end

    --- Retrieves a queue object by its identifier. If no queue is found, nil is
    --- returned, otherwise the queue object is returned.
    ---
    --- @param id string - The identifier of the queue to retrieve
    --- @return table|nil - The queue object or nil if not found
    function self.get(id)
      ___.v.type(id, "string", 1, false)

      for _, q in pairs(self.queues) do
        if q.id == id then return q end
      end
      return nil, f"Queue not found for id `{id}`."
    end

    --- Add a function to the end of a queue by its identifier.
    ---
    --- @param id string - The identifier of the queue to add the function to
    --- @param f function - The function to add to the queue
    --- @example
    --- ```lua
    --- queue:push("2ce02d6a-36a8-45ab-a78e-7f909427e1d1",
    ---   function() print("Hello, world!")
    --- end)
    --- ```
    function self.push(id, f)
      ___.v.type(id, "string", 1, false)
      ___.v.type(f, "function", 2, false)

      local q, err = self:get(id)
      if not q then return nil, err end

      return q.push(f)
    end

    function self.shift(id)
      ___.v.type(id, "string", 1, false)

      local q, err = self.get(id)
      if not q then return nil, err end

      return q.shift()
    end
  end
})


-- File: queue_stack.lua
local QueueStackClass = Glu.glass.register({
  name = "queue_stack",
  class_name = "QueueStackClass",
  dependencies = { "table" },
  setup = function(___, self, opts, container)
    if not opts.funcs then return end

    local funcs = opts.funcs or {}

    funcs = ___.table.n_cast(funcs)
    ___.v.n_uniform(funcs, "function", 2, false)

    self.stack = funcs
    self.id = ___.id()

    function self.push(f)
      ___.v.type(f, "function", 1, false)
      return ___.table.push(self.stack, f)
    end

    function self.shift()
      return ___.table.shift(self.stack)
    end

    function self.execute(...)
      -- Shift the next task off the queue
      local task = self.shift()
      if not task then
        return self, nil -- Queue is empty, return nil for remaining count
      end

      -- Execute the task with the provided arguments and store the result(s)
      local result = { task(self, ...) }

      -- Determine remaining task count, returning nil if no tasks remain
      local count = #self.stack
      return self, count > 0 and count or nil, unpack(result)
    end
  end
})


-- File: regex.lua
local RegexClass = Glu.glass.register({
  name = "regex",
  class_name = "RegexClass",
  dependencies = {},
  setup = function(___, self)
    self.http_url = "^(https?:\\/\\/)((([A-Za-z0-9-]+\\.)+[A-Za-z]{2,})|localhost)(:\\d+)?(\\/[^\\s]*)?$"
  end,
  valid = function(___, self)
    return {
      regex = function(value, pattern, argument_index, nil_allowed)
        if nil_allowed and value == nil then
          return
        end

        local last = ___.get_last_traceback_line()

        assert(rex.match(value, pattern), "Invalid value to argument " ..
          argument_index .. ". Expected " .. pattern .. ", got " .. value ..
          " in\n" .. last)
      end
    }
  end
})


-- File: same.lua
local SameClass = Glu.glass.register({
  name = "same",
  class_name = "SameClass",
  dependencies = { "table" },
  setup = function(___, self)
    --- Checks if two values are the same, including special cases for NaN and zero.
    --- @param value1 any - The first value to compare.
    --- @param value2 any - The second value to compare.
    --- @return boolean - True if the values are the same, false otherwise.
    function self.value_zero(value1, value2)
      ___.v.type(value1, "any", 1, false)
      ___.v.type(value2, "any", 2, false)

      -- If types are different, return false
      if type(value1) ~= type(value2) then
        return false
      end

      -- If type is 'number', handle special cases for NaN and zero
      if type(value1) == "number" then
        if value1 ~= value1 and value2 ~= value2 then -- Check if both x and y are NaN
          return true
        elseif value1 == 0 and value2 == 0 then
          -- Handle +0 and -0
          return true
        elseif value1 == value2 then
          return true
        else
          return false
        end
      end

      -- For non-number values, use a simple equality check
      return value1 == value2
    end

    --- Checks if two values are the same, including special cases for NaN and zero.
    --- @param value1 any - The first value to compare.
    --- @param value2 any - The second value to compare.
    --- @return boolean - True if the values are the same, false otherwise.
    function self.value(value1, value2)
      ___.v.type(value1, "any", 1, false)
      ___.v.type(value2, "any", 2, false)

      -- If types are different, return false
      if type(value1) ~= type(value2) then
        return false
      end

      -- If type is 'number', handle special cases for NaN and zero
      if type(value1) == "number" then
        if value1 ~= value1 and value2 ~= value2 then -- Check if both x and y are NaN
          return true
        elseif value1 == 0 and value2 == 0 then
          -- Handle +0 and -0 (they are considered different)
          return 1 / value1 == 1 / value2 -- +0 and -0 have different reciprocals
        elseif value1 == value2 then
          return true
        else
          return false
        end
      end

      -- For non-number values, use a simple equality check
      return value1 == value2
    end
  end
})


-- File: string.lua
local StringClass = Glu.glass.register({
  name = "string",
  class_name = "StringClass",
  dependencies = { "table" },
  setup = function(___, self)
    --- Capitalizes the first character of a string.
    ---
    --- @param str string - The string to capitalize.
    --- @return string - The capitalized string.
    --- @example
    --- ```lua
    --- string.capitalize("hello")
    --- -- "Hello"
    --- ```
    function self.capitalize(str)
      ___.v.type(str, "string", 1, false)
      assert(str ~= "", "Expected a non-empty string")

      local result = str:gsub("^%l", string.upper)
      return result or str
    end

    --- Trims whitespace from the beginning and end of a string.
    ---
    --- @param str string - The string to trim.
    --- @return string - The trimmed string.
    --- @example
    --- ```lua
    --- string.trim("  hello  ")
    --- -- "hello"
    --- ```
    function self.trim(str)
      ___.v.type(str, "string", 1, false)
      return str:match("^%s*(.-)%s*$")
    end

    --- Trims whitespace from the left side of a string.
    ---
    --- @param str string - The string to trim.
    --- @return string - The trimmed string.
    --- @example
    --- ```lua
    --- string.ltrim("  hello  ")
    --- -- "hello  "
    --- ```
    function self.ltrim(str)
      ___.v.type(str, "string", 1, false)
      return str:match("^%s*(.-)$")
    end

    --- Trims whitespace from the right side of a string.
    ---
    --- @param str string - The string to trim.
    --- @return string - The trimmed string.
    --- @example
    --- ```lua
    --- string.rtrim("  hello  ")
    --- -- "  hello"
    --- ```
    function self.rtrim(str)
      ___.v.type(str, "string", 1, false)
      return str:match("^.-%s*$")
    end

    --- Strips line breaks from a string.
    ---
    --- @param str string - The string to strip line breaks from.
    --- @return string - The string with line breaks removed.
    --- @example
    --- ```lua
    --- string.strip_linebreaks("hello\nworld")
    --- -- "helloworld"
    --- ```
    function self.strip_linebreaks(str)
      ___.v.type(str, "string", 1, false)
      local result, found, subbed = rex.gsub(str, "[\\r\\n]", "")
      return result or str
    end

    --- Replaces all occurrences of a pattern in a string.
    ---
    --- @param str string - The string to replace occurrences in.
    --- @param pattern string - The pattern to replace.
    --- @param replacement string - The replacement string.
    --- @return string - The string with occurrences replaced.
    --- @example
    --- ```lua
    --- string.replace("hello world", "o", "a")
    --- -- "hella warld"
    --- ```
    function self.replace(str, pattern, replacement)
      ___.v.type(str, "string", 1, false)
      ___.v.type(pattern, "string", 2, false)
      ___.v.type(replacement, "string", 3, false)

      while string.find(str, pattern) do
        str = string.gsub(str, pattern, replacement) or str
      end

      return str
    end

    --- Splits a string into a table of strings using PCRE regex. If no
    --- delimiter is provided, it defaults to ".", which will split the string
    --- into individual characters.
    ---
    --- @param str string - The string to split.
    --- @param delimiter string - The regex delimiter to split the string by.
    --- @return table - The split string.
    --- @example
    --- ```lua
    --- string.split("hello world")
    --- -- {"h", "e", "l", "l", "o", " ", "w", "o", "r", "l", "d"}
    ---
    --- string.split("hello world", " ")
    --- -- {"hello", "world"}
    ---
    --- string.split("hello.world", "\\.")
    --- -- {"hello", "world"}
    ---
    --- string.split("hello world", "o")
    --- -- {"hell", " w", "rld"}
    --- ```
    function self.split(str, delimiter)
      ___.v.type(str, "string", 1, false)
      ___.v.type(delimiter, "string", 2, true)

      local t = {}
      delimiter = delimiter or "."

      for part in str:gmatch("[^" .. delimiter .. "]+") do
        table.insert(t, part)
      end

      return t
    end

    --- Walks over a string or table, splitting the string with a PCRE regex
    --- delimiter and returning an iterator.
    ---
    --- @param input string - The string to walk over.
    --- @param delimiter string - The regex delimiter to split the string by.
    --- @return function - The iterator function.
    --- @example
    --- ```lua
    --- for i, part in string.walk("hello world") do
    ---   print(i, part) -- prints 1=h, 2=e, 3=l, 4=l, 5=o, 6= , 7=w, 8=o, 9=r, 10=l, 11=d
    --- end
    --- ```
    function self.walk(input, delimiter)
      ___.v.type(input, "string", 1, false)
      ___.v.type(delimiter, "string", 2, true)

      local data
      if type(input) == "string" then
        data = self.split(input, delimiter)
      else
        data = input
      end

      return ___.table.walk(data)
    end

    --- Formats a number with thousands separators and decimal places.
    --- If not specified, defaults to "," for thousands and "." for decimal.
    ---
    --- @example
    --- ```lua
    --- string.format_number(1234567.89)
    --- -- "1,234,567.89"
    --- ```
    --- @param number string|number - The number to format (number or string)
    --- @param thousands string - The thousands separator (optional, defaults to ",")
    --- @param decimal string - The decimal separator (optional, defaults to ".")
    --- @return string - The formatted number
    function self.format_number(number, thousands, decimal)
      ___.v.type(number, { "number|string" }, 1, false)
      ___.v.type(thousands, "string", 2, true)
      ___.v.type(decimal, "string", 3, true)

      -- Set defaults
      thousands = thousands or ","
      decimal = decimal or "."

      number = tonumber(number) or 0
      local is_negative = not ___.number.positive(number)
      number = math.abs(number)

      -- Convert to string if needed
      local numStr = tostring(number)

      -- Split integer and decimal parts
      local intPart, decPart = numStr:match("([^%.]*)%.?(.*)")

      -- Add thousands separators to integer part
      local formatted = ""
      local length = #intPart

      for i = 1, length do
        if i > 1 and (length - i + 1) % 3 == 0 then
          formatted = thousands .. formatted
        end
        formatted = intPart:sub(length - i + 1, length - i + 1) .. formatted
      end

      -- Add decimal part if it exists
      if decPart and decPart ~= "" then
        formatted = formatted .. decimal .. decPart
      end

      -- Restore negative sign if needed
      if is_negative then formatted = "-" .. formatted end

      return formatted
    end

    --- Parses a formatted number string back to a number.
    ---
    --- @param str string - The formatted number string.
    --- @param thousands string - The thousands separator (optional, defaults to ",").
    --- @param decimal string - The decimal separator (optional, defaults to ".").
    --- @return number - The parsed number.
    --- @example
    --- ```lua
    --- string.parse_formatted_number("1,234,567.89")
    --- -- 1234567.89
    --- ```
    function self.parse_formatted_number(str, thousands, decimal)
      ___.v.type(str, "string", 1, false)
      ___.v.type(thousands, "string", 2, true)
      ___.v.type(decimal, "string", 3, true)

      thousands = thousands or ","
      decimal = decimal or "."

      -- Remove thousands separators
      str = str:gsub(thousands, "") or str

      -- Convert decimal separator to period if different
      if decimal ~= "." then
        str = str:gsub(decimal, ".") or str
      end

      -- Convert to number
      return tonumber(str) or 0
    end

    --- Checks if a string starts with a given PCRE regex pattern.
    --- If the pattern does not start with "^", it is prepended with "^".
    ---
    --- @param str string - The string to check.
    --- @param start string - The pattern to check for.
    --- @return boolean - Whether the string starts with the pattern.
    --- @example
    --- ```lua
    --- string.starts_with("hello world", "hello")
    --- -- true
    --- ```
    function self.starts_with(str, start)
      ___.v.type(str, "string", 1, false)
      ___.v.type(start, "string", 2, false)

      start = string.sub(start, 1) == "^" and start or "^" .. start

      return rex.match(str, start) ~= nil
    end

    --- Checks if a string ends with a given PCRE regex pattern.
    --- If the pattern does not end with "$", it is appended with "$".
    ---
    --- @param str string - The string to check.
    --- @param ending string - The pattern to check for.
    --- @return boolean - Whether the string ends with the pattern.
    --- @example
    --- ```lua
    --- string.ends_with("hello world", "world")
    --- -- true
    --- ```
    function self.ends_with(str, ending)
      ___.v.type(str, "string", 1, false)
      ___.v.type(ending, "string", 2, false)

      ending = string.sub(ending, 1) == "$" and ending or ending .. "$"

      return rex.match(str, ending) ~= nil
    end

    --- Checks if a string contains a given PCRE regex pattern. The pattern
    --- may not start with "^" or end with "$". For those, use
    --- `string.starts_with` and `string.ends_with`.
    ---
    --- @param str string - The string to check.
    --- @param pattern string - The pattern to check for.
    --- @return boolean - Whether the string contains the pattern.
    --- @example
    --- ```lua
    --- string.contains("hello world", "world")
    --- -- true
    --- ```
    function self.contains(str, pattern)
      ___.v.type(str, "string", 1, false)
      ___.v.type(pattern, "string", 2, false)
      ___.v.test(not self.starts_with(pattern, "^"), "Expected pattern to not start with ^", 2)
      ___.v.test(not self.ends_with(pattern, "$"), "Expected pattern to not end with $", 2)

      return rex.match(str, pattern) ~= nil
    end

    --- Appends a suffix to a string if it does not already end with the suffix.
    ---
    --- @param str string - The string to append to.
    --- @param suffix string - The suffix to append.
    --- @return string - The string with the suffix appended.
    --- @example
    --- ```lua
    --- string.append("hello", " world")
    --- -- "hello world"
    --- ```
    function self.append(str, suffix)
      ___.v.type(str, "string", 1, false)
      ___.v.type(suffix, "string", 2, false)

      return self.ends_with(str, suffix) and str or str .. suffix
    end

    --- Prepends a prefix to a string if it does not already start with the prefix.
    ---
    --- @param str string - The string to prepend to.
    --- @param prefix string - The prefix to prepend.
    --- @return string - The string with the prefix prepended.
    --- @example
    --- ```lua
    --- string.prepend("world", "hello ")
    --- -- "hello world"
    --- ```
    function self.prepend(str, prefix)
      ___.v.type(str, "string", 1, false)
      ___.v.type(prefix, "string", 2, false)

      return self.starts_with(str, prefix) and str or prefix .. str
    end

    --- Implementation of reg_assoc for Mudlet using rex PCRE support
    --- @param text string - The text to search through
    --- @param patterns table - The patterns to search for
    --- @param tokens table - The tokens to replace the patterns with
    --- @param default_token string - The default token to use if no pattern is found (optional, defaults to "")
    --- @return table,table - A table of results and token list
    --- @example
    --- ```lua
    --- string.reg_assoc("hello world", {"hello", "world"}, {"foo", "bar"})
    --- -- {"foo", "bar"}
    --- ```
    function self.reg_assoc(text, patterns, tokens, default_token)
      default_token = default_token or -1
      local work = text

      local results = {}
      local token_list = {}


      while #work > 0 do
        local nearest_from, nearest_match, nearest_token = nil, nil, nil

        for i, pattern in ipairs(patterns) do
          local from, to = rex.find(work, pattern)
          if from and to then
            if not nearest_from or from < nearest_from then
              nearest_from, nearest_match, nearest_token =
              from, work:sub(from, to), tokens[i] or default_token
            end
          end
        end

        local prematch = ""
        local token = nearest_token or default_token
        local match = nearest_match or work
        nearest_from = nearest_from or #work
        prematch = work:sub(1, nearest_from - 1 or nil)
        print("Prematch = `" .. tostring(prematch) .. "` with token `" .. tostring(token) .. "` and match `" .. tostring(match) .. "`")

        work = work:sub(nearest_from + #match) or ""
--[[
        if nearest_from then
          token = nearest_token or default_token
          match = nearest_match or work
          prematch = ""
        else
          token = default_token
          nearest_from = #work
          match = work
          work = ""
          break
        end

        -- The text between 1 and the nearest match
        local pre_match = work:sub(1, nearest_from - 1 or nil)
--]]
        -- Add it to the results
        table.insert(results, pre_match)
        table.insert(token_list, default_token)

        if #match > 0 then
          table.insert(results, match)
          table.insert(token_list, token)
        end
      end

      return results, token_list
    end
  end
})

-- { "this", " ", "is", " ", "a", " ", "test" }
-- { 1, nil, 1, nil, 1, nil, 1 }

-- this is a thing that is num3rically unsoundh4444, and my favourite number is forty2


-- File: table.lua
local TableClass = Glu.glass.register({
  name = "table",
  class_name = "TableClass",
  dependencies = {},
  setup = function(___, self)
    function self.n_cast(...)
      if type(...) == "table" and self.indexed(...) then
        return ...
      end

      return { ... }
    end

    self.assure_indexed = self.n_cast

    function self.map(t, fn, ...)
      ___.v.type(t, "table", 1, false)
      ___.v.type(fn, "function", 2, false)

      local result = {}
      for k, v in pairs(t) do
        result[k] = fn(k, v, ...)
      end
      return result
    end

    function self.values(t)
      ___.v.type(t, "table", 1, false)

      local result = {}
        for _, v in pairs(t) do
        result[#result + 1] = v
      end
      return result
    end

    function self.n_uniform(t, typ)
      ___.v.type(t, "table", 1, false)
      ___.v.not_empty(t, 1, false)
      ___.v.indexed(t, 1, false)
      ___.v.type(typ, "string", 2, true)

      typ = typ or type(t[1])

      for _, v in pairs(t) do
        if type(v) ~= typ then
          return false
        end
      end

      return true
    end

    function self.n_distinct(t)
      ___.v.indexed(t, 1, false)

      local result, seen = {}, {}
      for _, v in ipairs(t) do
        if not seen[v] then
          seen[v] = true
          result[#result + 1] = v
        end
      end
      return result
    end

    function self.pop(t)
      ___.v.type(t, "table", 1, false)
      ___.v.indexed(t, 1, false)
      return table.remove(t, #t)
    end

    function self.push(t, v)
      ___.v.type(t, "table", 1, false)
      ___.v.type(v, "any", 2, false)
      ___.v.indexed(t, 1, false)
      table.insert(t, v)

      return #t
    end

    function self.unshift(t, v)
      ___.v.type(t, "table", 1, false)
      ___.v.type(v, "any", 2, false)
      ___.v.indexed(t, 1, false)
      table.insert(t, 1, v)

      return #t
    end

    function self.shift(t)
      ___.v.type(t, "table", 1, false)
      ___.v.indexed(t, 1, false)
      return table.remove(t, 1)
    end

    function self.allocate(source, spec)
      local spec_type = type(spec)
      ___.v.type(source, "table", 1, false)
      ___.v.not_empty(source, 1, false)
      ___.v.indexed(source, 1, false)
      if spec_type == ___.TYPE.TABLE then
        ___.v.indexed(spec, 2, false)
        assert(#source == #spec, "Expected source and spec to have the same number of elements")
      elseif spec_type == ___.TYPE.FUNCTION then
        ___.v.type(spec, "function", 2, false)
      end

      local result = {}

      if spec_type == ___.TYPE.TABLE then
        for i = 1, #spec do
          result[source[i]] = spec[i]
        end
      elseif spec_type == ___.TYPE.FUNCTION then
        for i = 1, #source do
          result[source[i]] = spec(i, source[i])
        end
      else
        for i = 1, #source do
          result[source[i]] = spec
        end
      end

      return result
    end

    function self.indexed(t)
      ___.v.type(t, "table", 1, false)

      local index = 1
      for k in pairs(t) do
        if k ~= index then
          return false
        end
        index = index + 1
      end
      return true
    end

    function self.associative(t)
      ___.v.type(t, "table", 1, false)

      for k, _ in pairs(t) do
        if type(k) ~= "number" or k % 1 ~= 0 or k <= 0 then
            return true
        end
      end
      return false
    end

    function self.reduce(t, fn, initial)
      ___.v.indexed(t, 1, false)
      ___.v.type(fn, "function", 2, false)
      ___.v.type(initial, "any", 3, false)

      local acc = initial
      for k, v in pairs(t) do
        acc = fn(acc, v, k)
      end
      return acc
    end

    function self.slice(t, start, stop)
      ___.v.indexed(t, 1, false)
      ___.v.type(start, "number", 2, false)
      ___.v.type(stop, "number", 3, true)
      ___.v.test(start >= 1, 2, false)
      ___.v.test(table.size(t) >= start, 2, false)
      ___.v.test(stop and stop >= start, 3, true)

      if not stop then
        stop = #t
      end

      local result = {}
      for i = start, stop do
        result[#result + 1] = t[i]
      end
      return result
    end

    function self.remove(t, start, stop)
      ___.v.indexed(t, 1, false)
      ___.v.type(start, "number", 2, false)
      ___.v.type(stop, "number", 3, true)
      ___.v.test(start >= 1, 2, false)
      ___.v.test(table.size(t) >= start, 2, false)
      ___.v.test(stop and stop >= start, 3, true)

      local snipped = {}
      if not stop then stop = start end
      local count = stop - start + 1
      for i = 1, count do
        table.insert(snipped, table.remove(t, start))
      end
      return t, snipped
    end

    function self.chunk(t, size)
      ___.v.indexed(t, 1, false)
      ___.v.type(size, "number", 2, false)

      local result = {}
      for i = 1, #t, size do
        result[#result + 1] = ___.slice(t, i, i + size - 1)
      end
      return result
    end

    function self.concat(tbl, ...)
      ___.v.indexed(tbl, 1, false)

      local args = { ... }

      for _, tbl_value in ipairs(args) do
        if type(tbl_value) == "table" then
          for _, value in ipairs(tbl_value) do
            table.insert(tbl, value)
          end
        else
          table.insert(tbl, tbl_value)
        end
      end

      return tbl
    end

    function self.drop(tbl, n)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(n, "number", 2, false)
      ___.v.test(n >= 1, 2, false)
      return self.slice(___, tbl, n + 1)
    end

    function self.drop_right(tbl, n)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(n, "number", 2, false)
      ___.v.test(n >= 1, 2, false)
      return self.slice(___, tbl, 1, #tbl - n)
    end

    function self.fill(tbl, value, start, stop)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(value, "any", 2, false)
      ___.v.type(start, "number", 3, true)
      ___.v.type(stop, "number", 4, true)
      ___.v.test(start and start >= 1, value, 3, true)
      ___.v.test(stop and stop >= start, value, 4, true)

      for i = start or 1, stop or #tbl do
        tbl[i] = value
      end
      return tbl
    end

    function self.find(tbl, fn)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(fn, "function", 2, false)

      for i = 1, #tbl do
        if fn(i, tbl[i]) then
          return i
        end
      end
      return nil
    end

    function self.find_last(tbl, fn)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(fn, "function", 2, false)

      for i = #tbl, 1, -1 do
        if fn(i, tbl[i]) then
          return i
        end
      end
      return nil
    end

    function self.flatten(tbl)
      ___.v.indexed(tbl, 1, false)

      local result = {}
      for _, v in ipairs(tbl) do
        if type(v) == "table" then
          ___.concat(result, v)
        else
          table.insert(result, v)
        end
      end

      return result
    end

    function self.flatten_deeply(tbl)
      ___.v.indexed(tbl, 1, false)

      local result = {}
      for _, v in ipairs(tbl) do
        if type(v) == "table" then
          self.concat(result, self.flatten_deeply(v))
        else
          table.insert(result, v)
        end
      end

      return result
    end

    function self.initial(tbl)
      ___.v.indexed(tbl, 1, false)
      return self.slice(___, tbl, 1, #tbl - 1)
    end

    function self.pull(tbl, ...)
      ___.v.indexed(tbl, 1, false)

      local args = { ... }
      if #args == 0 then return tbl end

      local removeSet = {}
      for _, value in ipairs(args) do
        removeSet[value] = true
      end

      for i = #tbl, 1, -1 do
        if removeSet[tbl[i]] then
          table.remove(tbl, i)
        end
      end

      return tbl
    end

    function self.reverse(tbl)
      ___.v.indexed(tbl, 1, false)

      local len, midpoint = #tbl, math.floor(#tbl / 2)
      for i = 1, midpoint do
        tbl[i], tbl[len - i + 1] = tbl[len - i + 1], tbl[i]
      end
      return tbl
    end

    function self.uniq(tbl)
      ___.v.indexed(tbl, 1, false)

      local seen = {}
      local writeIndex = 1

      for readIndex = 1, #tbl do
        local value = tbl[readIndex]
        if not seen[value] then
          seen[value] = true
          tbl[writeIndex] = value
          writeIndex = writeIndex + 1
        end
      end

      -- Remove excess elements beyond writeIndex
      for i = #tbl, writeIndex, -1 do
        tbl[i] = nil
      end

      return tbl
    end

    function self.unzip(tbl)
      ___.v.indexed(tbl, 1, false)

      local size_of_table = #tbl
      -- Ensure that all sub-tables are of the same length
      local size_of_elements = #tbl[1]
      for _, t in ipairs(tbl) do ___.v.test(size_of_elements == #t, t, 1, false) end

      local num_new_sub_tables = size_of_elements -- yes, this is redundant, but it's more readable
      local new_sub_table_size = size_of_table -- this is the size of the sub-tables
      local result = {}

      for i = 1, num_new_sub_tables do
        result[i] = {}
      end

      for _, source_table in ipairs(tbl) do
        for i, value in ipairs(source_table) do
          table.insert(result[i], value)
        end
      end

      return result
    end

    function self.new_weak(opt)
      ___.v.test(rex.match(opt, "^(k?v?|v?k?)$"), opt, 1, true)

      opt = opt or "v"

      return setmetatable({}, { __mode = opt })
    end

    function self.weak(tbl)
      ___.v.type(tbl, "table", 1, false)
      return getmetatable(tbl) and getmetatable(tbl).__mode ~= nil
    end

    function self.zip(...)
      local tbls = { ... }
      local results = {}

      local size = #tbls[1]
      for _, t in ipairs(tbls) do ___.v.test(size == #t, t, 1, false) end

      for i = 1, size do
        results[i] = {}
        for _, t in ipairs(tbls) do
          table.insert(results[i], t[i])
        end
      end
      return results
    end

    function self.includes(tbl, value)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(value, "any", 2, false)
      return table.index_of(tbl, value) ~= nil
    end

    local function collect_tables(tbl, inherited)
      -- Check if the table is a valid object with a metatable and an __index field
      ___.v.object(tbl, 1, false)
      ___.v.type(inherited, "boolean", 2, true)

      -- Set-like table to track visited tables
      local visited = {}
      local tables = {}

      local function add_table(t)
        if not visited[t] then
          table.insert(tables, t)
          visited[t] = true
        end
      end

      -- Start by adding the main table
      add_table(tbl)

      if inherited then
        local mt = getmetatable(tbl)
        while mt and mt.__index do
          local inheritedTbl = mt.__index
          if type(inheritedTbl) == "table" then
            add_table(inheritedTbl)
          end
          mt = getmetatable(inheritedTbl)
        end
      end

      return tables
    end

    local function get_types(tbl, test)
      ___.v.type(tbl, "table", 1, false)
      ___.v.type(test, "function", 2, false)

      local keys = table.keys(tbl)
      keys = table.n_filter(keys, function(k) return test(tbl, k) end) or {}
      return keys
    end

    local function assemble_results(tables, test)
      local result = {}
      for _, t in ipairs(tables) do
        local keys = get_types(t, test) or {}
        for _, k in ipairs(keys) do
          if not ___.table.includes(result, k) then
            table.insert(result, k)
          end
        end
      end
      return result
    end

    function self.functions(tbl, inherited)
      ___.v.object(tbl, 1, false)
      ___.v.type(inherited, "boolean", 2, true)

      local tables = collect_tables(tbl, inherited) or {}
      local test = function(t, k) return type(t[k]) == "function" end

      return assemble_results(tables, test)
    end
    -- Alias for functions
    self.methods = self.functions

    function self.properties(tbl, inherited)
      ___.v.object(tbl, 1, false)
      ___.v.type(inherited, "boolean", 2, true)

      local tables = collect_tables(tbl, inherited) or {}
      local test = function(t, k) return type(t[k]) ~= "function" end

      return assemble_results(tables, test)
    end

    function self.object(tbl)
      ___.v.type(tbl, "table", 1, false)
      return tbl.object == true
    end

    function self.add(tbl, value)
      ___.v.associative(tbl, 1, false)
      ___.v.associative(value, 2, false)

      for k, v in pairs(value) do
        tbl[k] = v
      end

      return tbl
    end

    function self.n_add(tbl1, tbl2, index)
      ___.v.indexed(tbl1, 1, false)
      ___.v.indexed(tbl2, 2, false)
      ___.v.range(index, 1, #tbl1 + 1, 3, true)

      -- We are not adding +1 to the end index because we will be doing +1
      -- in the loop below
      index = index or #tbl1 + 1

      for i = 1, #tbl2 do
        table.insert(tbl1, index + i - 1, tbl2[i])
      end

      return tbl1
    end

    function self.walk(tbl)
      ___.v.indexed(tbl, 1, false)

      local i = 0
      return function()
        i = i + 1
        if tbl[i] then return i, tbl[i] end
      end
    end

    function self.element_of(list)
      ___.v.type(list, "table", 1, false)

      local max = #list
      return list[math.random(max)]
    end

    function self.element_of_weighted(list)
      ___.v.type(list, "table", 1, false)

      local total = 0
      for _, value in pairs(list) do
        total = total + value
      end

      local random = math.random(total)

      for key, value in pairs(list) do
        random = random - value
        if random <= 0 then
          return key
        end
      end
    end

    local assure_equality_function = function(condition)
      if type(condition) ~= "function" then
        condition = function(_, k) return k == condition end
      end
      return condition
    end

    function self.all(tbl, condition)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(condition, "any", 2, false)

      local count = 0

      condition = assure_equality_function(condition)

      local result = table.n_filter(tbl, condition)
      if result then
        count = #result
      end

      return count == #tbl
    end

    function self.some(tbl, condition)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(condition, "any", 2, false)

      condition = assure_equality_function(condition)

      return table.n_filter(tbl, condition) ~= nil
    end

    function self.none(tbl, condition)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(condition, "any", 2, false)

      condition = assure_equality_function(condition)

      return table.n_filter(tbl, condition) == nil
    end

    function self.one(tbl, condition)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(condition, "any", 2, false)

      condition = assure_equality_function(condition)

      return table.n_filter(tbl, condition) ~= nil and #table.n_filter(tbl, condition) == 1
    end

    function self.count(tbl, condition)
      ___.v.indexed(tbl, 1, false)
      ___.v.type(condition, "any", 2, false)

      condition = assure_equality_function(condition)

      return #table.n_filter(tbl, condition)
    end
  end,
  valid = function(___, self)
    return {
      not_empty = function(value, argument_index, nil_allowed)
        assert(type(value) == "table", "Invalid type to argument " ..
          argument_index .. ". Expected table, got " .. type(value) .. " in\n" ..
          ___.get_last_traceback_line())
        if nil_allowed and value == nil then
          return
        end

        local last = ___.get_last_traceback_line()
        assert(not table.is_empty(value), "Invalid value to argument " ..
          argument_index .. ". Expected non-empty in\n" .. last)
      end,

      n_uniform = function(value, expected_type, argument_index, nil_allowed)
        if nil_allowed and value == nil then
          return
        end

        local last = ___.get_last_traceback_line()
        assert(self.n_uniform(value, expected_type),
          "Invalid type to argument " .. argument_index .. ". Expected an " ..
          "indexed table of " .. expected_type .. " in\n" .. last)
      end,
      indexed = function(value, argument_index, nil_allowed)
        if nil_allowed and value == nil then
          return
        end

        local last = ___.get_last_traceback_line()
        assert(self.indexed(value), "Invalid value to argument " ..
          argument_index .. ". Expected indexed table, got " .. type(value) ..
          " in\n" .. last)
      end,
      associative = function(value, argument_index, nil_allowed)
        if nil_allowed and value == nil then
          return
        end

        local last = ___.get_last_traceback_line()

        assert(self.associative(value),
          "Invalid value to argument " .. argument_index .. ". Expected " ..
          "associative table, got " .. type(value) .. " in\n" .. last)
      end,
      object = function(value, argument_index, nil_allowed)
        if nil_allowed and value == nil then
          return
        end

        local last = ___.get_last_traceback_line()
        assert(self.object(value), "Invalid value to argument " ..
          argument_index .. ". Expected object, got " .. type(value) ..
          " in\n" .. last)
      end,
      option = function(value, options, argument_index)
        ___.v.type(value, "any", argument_index, false)
        ___.v.indexed(options, argument_index, false)
        ___.v.type(argument_index, "number", 3, false)

        local last = ___.get_last_traceback_line()
        assert(table.index_of(options, value) ~= nil, "Invalid value to " ..
          "argument " .. argument_index .. ". Expected one of " ..
          table.concat(options, ", ") .. ", got " .. value .. " in\n" .. last)
      end
    }
  end,
})


-- File: test.lua
local TestClass = Glu.glass.register({
  name = "test",
  class_name = "TestClass",
  call = "runner",
  dependencies = { "table", "test_runner" },
  setup = function(___, self)
    local testers = {}

    function self.runner(opts)
      local runner = ___.test_runner(opts, self)

      testers[runner.id] = runner

      return runner
    end

    local function sum(tests)
      local result = 0

      for _, test in ipairs(tests) do
        result = result + test
      end

      return result
    end

    local function sum_field(tbls, field)
      local totals = {}

      for _, tbl in ipairs(tbls) do
        table.insert(totals, tbl[field])
      end

      return sum(totals)
    end

    function self.summary(runner)
      local good_colour, bad_colour = unpack(___.table.values(runner.colours))
      local total_run = sum_field(runner.tests, "total")
      local total_pass = sum_field(runner.tests, "passes")
      local total_fail = sum_field(runner.tests, "fails")

      print("")
      cecho("<b> Tests run:</b> <gold>" .. total_run .. "<r>\n")
      cecho("<b> Successes:</b> " .. good_colour .. total_pass .. "<r>\n")
      cecho("<b>  Failures:</b> " .. bad_colour .. total_fail .. "<r>\n")
    end

    return self
  end
})


-- File: test_runner.lua
local TestRunnerClass = Glu.glass.register({
  name = "test_runner",
  class_name = "TestRunnerClass",
  call = "new_runner",
  dependencies = { "table" },
  setup = function(___, self)
    function self.new_runner(opts, owner)
      self.id = ___.id()
      self.tests = {}
      self.colours = {
        pass = (opts.colour and opts.colour.pass) or "<yellow_green>",
        fail = (opts.colour and opts.colour.fail) or "<orange_red>",
      }
      self.symbols = {
        -- check mark
        pass = (opts.symbol and opts.symbol.pass) or utf8.escape("%x{2714}"),
        -- cross mark
        fail = (opts.symbol and opts.symbol.fail) or utf8.escape("%x{2718}"),
      }
      ___.v.colour_name(self.colours.pass, 2, false)
      ___.v.colour_name(self.colours.fail, 2, false)

      local cond = ___.conditions
      local default = { tests = {} }
      local resets = { passes = 0, fails = 0, total = 0 }

      function self.add(name, test)
        table.insert(self.tests, {
          name = name,
          test = test,
          passes = 0,
          fails = 0,
          total = 0,
          runner = self,
        })

        return self
      end

      function self.remove(name)
        for i, test in ipairs(self.tests) do
          if test.name == name then
            table.remove(self.tests, i)
            return self
          end
        end

        error(f "Test '{name}' not found")
      end

      if opts.tests then
        repeat
          local name, test = unpack(
            ___.table.values(table.remove(opts.tests, 1))
          )
          self.add(name, test)
        until table.size(opts.tests) == 0
      end

      function self.print()
        for _, test in ipairs(self.tests) do
          cecho(f "<b>{test.name}<r>\n")
        end

        return self
      end

      function self.reset()
        for k, v in pairs(resets) do
          for _, test in ipairs(self.tests) do
            test[k] = v
          end
        end

        return self
      end

      function self.wipe()
        for _, v in pairs(self.tests) do
          v = nil
        end

        return self
      end

      function self.pass(test)
        test.total = test.total + 1
        test.passes = test.passes + 1
      end

      function self.fail(test)
        test.total = test.total + 1
        test.fails = test.fails + 1
      end

      function self.execute(reset_when_done)
        reset_when_done = reset_when_done or false

        self.reset()

        for _, t in ipairs(self.tests) do
          local status_message =
              f "<light_goldenrod>Running test '{t.name}' " ..
              "(<r><seashell>%d<r><light_goldenrod>): "

          local success, result, fail_message = (function(test, condition)
            registerNamedEventHandler(test.name, test.name, "condition_is",
              function(_, c)
                if c == true then
                  self.pass(test)
                elseif c == false then
                  self.fail(test)
                else
                  error(f "Expected a boolean, got {c}")
                end
              end
            )

            local success, result, fail_message = pcall(test.test, condition, self, test)

            deleteNamedEventHandler(test.name, test.name)

            return success, result, fail_message
          end)(t, cond)

          -- If we didn't succeed in our pcall OR we failed tests
          if not success or not result then
            self.fail(t)
            status_message =
                status_message .. self.colours.fail .. self.symbols.fail .. "\n" ..
                " " .. self.colours.fail .. "Error in test '" .. t.name .. "':\n" ..
                "  " .. tostring(result or fail_message) .. "\n"
          else
            self.pass(t)
            status_message = status_message .. self.colours.pass .. self.symbols.pass .. "\n"
          end

          status_message = string.format(status_message, t.total)
          cecho(status_message)
        end

        owner.summary(self)

        if reset_when_done then self.reset() end

        return self
      end
      return self
    end
  end
})


-- File: timer.lua
local TimerClass = Glu.glass.register({
  name = "timer",
  class_name = "TimerClass",
  dependencies = { "table" },
  setup = function(___, self)
    self.multi_timers = {}

    local function perform_multi_timer_function(name)
      local timer_function = mod.multi_timers[name]
      if not timer_function then
        return false
      end

      local defs = timer_function.def
      local def = defs[1]
      local ok, result = pcall(def.func, def.args)

      if not ok then
        return false
      end

      table.remove(defs, 1)
      if #defs > 0 then
        local result2 = ___.timer.multi(name, defs)
        if not result2 then
          return false
        end
      else
        ___.timer.kill_multi(name)
      end

      return true
    end

    --- Creates nested timers and returns true if successful.
    --- @param name string - The name of the multi timer.
    --- @param def table - The definition of the multi timer.
    --- @param delay number - The delay between each timer.
    --- @return boolean - True if the multi timer was created, errors out if not.
    --- @example
    --- ```lua
    --- -- At intervals of 5 seconds, print "hi", "there", "you", "amazing", and
    --- -- "developer"
    --- timer.multi("Greetings", {
    ---   { func = function() echo("hi\n") end },
    ---   { func = function() echo("there\n") end },
    ---   { func = function() echo("you\n") end },
    ---   { func = function() echo("amazing\n") end },
    ---   { func = function() echo("developer\n") end },
    --- }, 5)
    --- ```
    ---
    --- ```lua
    --- -- After 1s, print "hi", after 3s, print "there", after 6s, print "you",
    --- -- after 10s, print "amazing", and after 15s, print "developer"
    --- timer.multi("Greetings", {
    ---   { delay = 1, func = function() echo("hi\n") end },
    ---   { delay = 2, func = function() echo("there\n") end },
    ---   { delay = 3, func = function() echo("you\n") end },
    ---   { delay = 4, func = function() echo("amazing\n") end },
    ---   { delay = 5, func = function() echo("developer\n") end },
    --- })
    --- ```
    function self.multi(name, def, delay)
      ___.v.type(name, "string", 1, false)
      ___.v.not_empty(def, 2, false)
      ___.v.type(delay, "number", 3, true)

      if delay then
        def = ___.table.map(def, function(_, element)
          element.delay = delay
          return element
        end)
      end

      -- Record the initial information
      self.multi_timers[name] = { def = def }

      local timer_result
      local timer_id = tempTimer(def[1].delay, function()
        timer_result = perform_multi_timer_function(name)
      end)

      if not timer_id then
        ___.timer.kill_multi(name)
        return false
      end

      -- Record the timer id
      self.multi_timers[name].id = timer_id

      return true
    end

    --- Kills a multi timer by name.
    --- @param name string - The name of the multi timer.
    --- @return boolean|nil - True if the multi timer was killed, nil if it doesn't exist.
    --- @example
    --- ```lua
    --- timer.kill_multi("Greetings")
    --- ```
    function self.kill_multi(name)
      ___.v.type(name, "string", 1, false)

      local timer_function = self.multi_timers[name]
      if not timer_function then return nil end

      self.multi_timers[name] = nil
      local id = timer_function.id

      if id then
        return killTimer(id)
      end

      return true
    end
  end
})


-- File: try.lua
local TryClass = Glu.glass.register({
  class_name = "TryClass",
  name = "try",
  inherit_from = nil,
  call = "clone",
  setup = function(___, self, opts)
    local result = {
      try = nil,
      catch = nil,
      finally = nil,
      result = nil
    }

    function self.clone(f, ...)
      local glass = ___.getGlass("try")
      assert(glass, "TryClass not found")
      local try = glass(opts, self)
      return try.try(f, ...)
    end

    -- first, let's try to execute the function
    function self.try(f, ...)
      local success, try_result, b = pcall(f, ...)
      if success and try_result then
        result.try = {
          success = success,
          error = nil,
          result = try_result
        }
        result.result = try_result
      else
        self.caught = true
        result.try = {
          success = success,
          error = try_result,
          result = nil
        }
      end

      return self
    end

    function self.catch(f)
      local success, catch_result = pcall(f, result.try)
      if success then
        catch_result.catch = { success = true, error = nil }
      end
      return self
    end

    function self.finally(f)
      -- Pass both success and error information to finally block
      local success, finally_result = pcall(f, result)

      -- If finally block itself errors, we should probably handle that
      if not success then
        error("Error in finally block: " .. finally_result)
      end
      return self
    end
  end
})


-- File: url.lua
local UrlClass = Glu.glass.register({
  name = "url",
  class_name = "UrlClass",
  dependencies = { "table" },
  setup = function(___, self)
    --- Decodes a string that has been URL-encoded. Useful for decoding query
    --- parameters into a more readable format.
    ---
    --- @param str string - The URL-encoded string to decode.
    --- @return string - The decoded string.
    --- @example
    --- ```lua
    --- url:decode("This%20string%20is%20now%20readable%21%21%21")
    --- -- "This string is now readable!!!"
    --- ```
    function self.decode(str)
      ___.v.type(str, "string", 1, false)

      str = (string.gsub(str, '+', ' ') or str)
      str = (string.gsub(str, '%%(%x%x)', function(h)
        return string.char(tonumber(h, 16))
      end) or str)
      return str
    end

    --- Encodes a string into a URL-encoded string. Useful for encoding query
    --- parameters into a URL before sending it to a server.
    ---
    --- @param str string - The string to encode.
    --- @return string - The URL-encoded string.
    --- @example
    --- ```lua
    --- url:encode("This string is now usable in a URL.")
    --- -- "This%20string%20is%20now%20usable%20in%20a%20URL%2E"
    --- ```
    function self.encode(str)
      ___.v.type(str, "string", 1, false)

      str = (string.gsub(str, "([^%w])", function(c)
        return string.format("%%%02X", string.byte(c))
      end) or str)
      return str
    end

    --- Parses a query string into a table of key-value pairs.
    ---
    --- @param query_string string - The query string to parse.
    --- @return table - A table containing the parsed key-value pairs.
    --- @example
    --- ```lua
    --- url:decode_params("name=John&age=30")
    --- -- { name = "John", age = "30" }
    --- ```
    function self.decode_params(query_string)
      local params = {}
      for key_value in rex.gmatch(query_string, "([^&]+)") do
        local key, value = rex.match(key_value, "([^=]+)=([^=]+)")
        if key and value then
          params[self.decode(key)] = self.decode(value)
        end
      end
      return params
    end

    --- Encodes a table of key-value pairs into a query string.
    ---
    --- @param params table - The table of key-value pairs to encode.
    --- @return string - The encoded query string.
    --- @example
    --- ```lua
    --- url:encode_params({ name = "John", age = "30" })
    --- -- "name=John&age=30"
    --- ```
    function self.encode_params(params)
      local encoded = {}
      for key, value in pairs(params) do
        table.insert(encoded, self.encode(key) .. "=" .. self.encode(value))
      end
      return table.concat(encoded, "&") or ""
    end

    --- Parses a URL into its components.
    ---
    --- @param url string - The URL to parse.
    --- @return table - A table containing the parsed URL components.
    --- @example
    --- ```lua
    --- url:parse("https://example.com/path/dosomething?name=John&age=30")
    --- -- {
    --- --   protocol = "https",
    --- --   host = "example.com",
    --- --   port = 443,
    --- --   path = "path/dosomething",
    --- --   file = "dosomething",
    --- --   params = {
    --- --     age = "30",
    --- --     name = "John"
    --- --   }
    --- -- }
    --- ```
    function self.parse(url)
      ___.v.type(url, "string", 1, false)

      local protocol, host, port, path, query_string = rex.match(url, "^(https?)://([^/:]+)(?::(\\d+))?/([^?]*)\\??(.*)")
      local file = (rex.match(path, "([^/]+)$") or path)
      local params = self.decode_params(query_string or "")

      protocol = protocol and protocol or "http"
      port = port and tonumber(port) or
        protocol and (protocol == "http" and 80 or 443)

      local parsed = {
        protocol = protocol,
        host = host,
        port = port,
        path = path,
        file = file,
        params = params
      }

      return parsed
    end
  end
})


-- File: version.lua
local VersionClass = Glu.glass.register({
  name = "version",
  class_name = "VersionClass",
  dependencies = { "table" },
  setup = function(___, self)
    --- Returns 1 if one is greater than two, -1 if one is less than two, and 0 if they are the same
    local function _compare(one, two)
      if one == two then
        return 0
      end

      if type(one) == "number" then
        return one < two and -1 or 1
      elseif type(one) == "string" then
        return one < two and -1 or 1
      end

      return one < two and -1 or 1
    end

    --- Compares two version strings. They can be a number, or a string. If a
    --- string, then it can be a string representation of a number or a semver
    --- string.
    ---
    --- @param version1 string|number - The first version string or number.
    --- @param version2 string|number - The second version string or number.
    --- @return number - 1 if version1 is greater than version2, -1 if version1 is less than version2, and 0 if they are the same.
    --- @example
    --- ```lua
    --- version.compare("1.0.0", "2.0.0")
    --- -- -1
    --- ```
    function self.compare(version1, version2)
      -- The versions must be of the same type
      ___.v.test(type(version1) == "string" or type(version1) == "number", 1, "Invalid value to argument 1. Expected a string or number.")
      ___.v.test(type(version2) == "string" or type(version2) == "number", 2, "Invalid value to argument 2. Expected a string or number.")
      ___.v.same_type(version1, version2)

      version1 = tostring(version1)
      version2 = tostring(version2)

      -- Split the versions into parts
      local version1_parts = version1:split("%.") or {}
      local version2_parts = version2:split("%.") or {}

      ___.v.test(type(version1_parts) == "table", 1, "Invalid value to argument 1. Expected a string.")
      ___.v.test(type(version2_parts) == "table", 2, "Invalid value to argument 2. Expected a string.")

      ___.v.test(#version1_parts == #version2_parts, 1, "Invalid value to arguments. Expected 1 and 2 to have the same number of parts.")

      for i = 1, #version1_parts do
        local result = _compare(version1_parts[i], version2_parts[i])
        if result ~= 0 then
          return result
        end
      end

      return 0
    end
  end
})
